<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>The Singleton Pattern</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">The Singleton Pattern</div>
	<span class="post-date">
		<time>11 Jul 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#design-pattern">
					<span>design-pattern</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="definition">Definition</h2>
<p>In some cases, our program requires that a certain class should have only one instance, such as the <code class="highlighter-rouge">Printer</code> class and <code class="highlighter-rouge">ThreadPool</code> class in Java. This design pattern is called <code class="highlighter-rouge">Singleton Pattern</code>:</p>

<blockquote>
  <p>To restrict the instantiation of a class to one object, and provide a global access point.</p>
</blockquote>

<h2 id="the-simplest-singleton-pattern">The Simplest Singleton Pattern</h2>
<p>Let’s answer an interesting question first: Can the <code class="highlighter-rouge">constructor</code> be decorated as<code class="highlighter-rouge">private</code> in Java?</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nf">Test</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>In fact, this code can be compiled, but what’s the meaning of this? How can we instantiate this class? We know that private methods can only be invoked inside the class, and since the only constructor is private, how to get into this class without an instance?</p>

<p>The answer is obvious now: we can create a <code class="highlighter-rouge">public static method</code> to invoke the constructor:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Test</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Test</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>This exercise gives us a method to implement the simplest sigleton pattern, that is, we can control the instantiation through a global static method and a private constructor. Actually, if we choose to create a class with sigleton pattern in <code class="highlighter-rouge">Intellij</code>, we will get the following template:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleSingleton</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">SimpleSingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
    
<span class="o">}</span>
</code></pre>
</div>

<p>It seems that we have perfectly addressed the problem! However, if you are familiar with the <code class="highlighter-rouge">class loading mechanism in Java</code>, you’ll know that <code class="highlighter-rouge">class-level static statements</code> are executed once the class is loaded. If unfortunately, the initialization process is time-consuming, and the instance of this class is never used after creation, this will be very wasteful.</p>

<h2 id="eager-loading--lazy-loading">Eager Loading &amp; Lazy Loading</h2>
<p>The method above is called <code class="highlighter-rouge">Eager Loading</code>, that is:</p>

<blockquote>
  <p>Whenever and whether the instance is used, always eargely create it during class loading.</p>
</blockquote>

<p>In contrast to this, we have another implementation:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleSingleton</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>                   <span class="c1">// a</span>
            <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>   <span class="c1">// b</span>

        <span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">SimpleSingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>This is the <code class="highlighter-rouge">Lazy Loading</code>:</p>

<blockquote>
  <p>Create the instance at the first request, and directly return it when requested again.</p>
</blockquote>

<h2 id="thread-safe-considerations">Thread-safe Considerations</h2>
<p>Althought the lazing loading achieves the delayed loading, it has a fatal problem: it is not thread-safe. If we use the following invokation sequence, two different instances will be created:</p>

<ol>
  <li><code class="highlighter-rouge">Thread #1</code> enters method <code class="highlighter-rouge">getInstance()</code>, and passes the <code class="highlighter-rouge">if</code> judgement at [a], but its time slice ends before executing <code class="highlighter-rouge">[b]</code>.</li>
  <li><code class="highlighter-rouge">Thread #2</code> enters method <code class="highlighter-rouge">getInstance()</code>, when <code class="highlighter-rouge">ourInstance</code> is still <code class="highlighter-rouge">null</code>, so it passes the judgement and executes <code class="highlighter-rouge">[b]</code>. Finally it creates a new <code class="highlighter-rouge">SimpleSigleton</code> instance and returns it.</li>
  <li><code class="highlighter-rouge">Thread #1</code> executes <code class="highlighter-rouge">[b]</code>, and creates a new <code class="highlighter-rouge">SimpleSigleton</code> instance, which overrides the instance created by <code class="highlighter-rouge">Thread #2</code>, and returns the new instance.</li>
</ol>

<p>To address this problem, using Java’s <code class="highlighter-rouge">synchronization (locking) mechanism</code> can be a good method:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span>  <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>

    <span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Synchronized methods</code> can only be accessed by one thread at one time, which fulfills the thread-safe requirement. However, it brings the <code class="highlighter-rouge">performance</code> issue: Java performs <code class="highlighter-rouge">locking</code> and <code class="highlighter-rouge">unlocking</code> operations when handling synchronized codes, and they may take some time.</p>

<p>In fact, after analyzing this code, we will find that synchronization is only indispensable at the first invocation, when the instance is not yet created. If we need to access this method many times, all synchronizations are meaningless except the the first time.</p>

<h2 id="double-checked-locking">Double-checked Locking</h2>
<p>To achieve thread-safe, and at the same time address the performance issue, some people suggested a more complicated solution:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span>  <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">SimpleSingleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Since only the instance creation statement requires to be locked, we use a <code class="highlighter-rouge">synchronized block</code> instead of synchronized method. Also, to avoid the problem we met in lazing loading, <code class="highlighter-rouge">ourInstance</code> is checked a second time inside the synchronization block before we really create a instance. As only one thread can access the synchronized block at one time, only one instance will be created.</p>

<h2 id="the-problem-brought-by-the-jvm">The Problem Brought by the JVM</h2>
<p>The double-checked locking seems to be perfect, but regrettably, it will not work in some cases. The problem is that the JVM allows the compiler to <code class="highlighter-rouge">reorder instructions</code>, which cannot guarantee the <code class="highlighter-rouge">orderliness (not sure)</code>. This may involve deeper analysis, and I don’t want to have further discussion concerning this topic in this blog, so I just give a conclusion:</p>

<blockquote>
  <p>Before the <code class="highlighter-rouge">new</code> operation finishes, the compiler may change the reference on the left of the <code class="highlighter-rouge">=</code> operator to <code class="highlighter-rouge">non-null</code> in advance. In multi-thread cases, a <code class="highlighter-rouge">not fully initialized object</code> will be returned.</p>
</blockquote>

<p>This sounds ridiculous, but it happens. However, luckily Java provides a mechanism to avoid this problem: the keyword <code class="highlighter-rouge">volative</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleSingleton</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="n">SimpleSingleton</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">// a</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span>  <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">SimpleSingleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">SimpleSingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>Pay attention to the statement at <code class="highlighter-rouge">[a]</code>, where we add a <code class="highlighter-rouge">volatile</code> to <code class="highlighter-rouge">ourInstance</code>. As for its specific function, I will discuss in another blog (maybe). What we need to know here is that the keyword <code class="highlighter-rouge">volatile</code> prohibits JVM from doing <code class="highlighter-rouge">instructions reordering</code>.</p>

<p>Therefore, finally, we have developed a thread-safe singleton pattern class with high-performance.</p>

<hr />

<h2 id="定义">定义</h2>
<p>在一些情况下，我们的程序需要保证某个类只有一个实例存在，比如 Java 中的 <code class="highlighter-rouge">打印机</code> 类，<code class="highlighter-rouge">线程池</code> 类。这种设计在设计模式中被称作单例模式，定义如下：</p>

<blockquote>
  <p>确保一个类只有一个实例，并提供一个全局访问点。</p>
</blockquote>

<p>这听起来似乎很好实现，但在实际应用的时候，还有很多需要考虑的因素。</p>

<h2 id="最简单的单例模式">最简单的单例模式</h2>
<p>先来回答一个有趣的问题，Java 的构造方法可以修饰为 <code class="highlighter-rouge">private</code> 吗？</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="nf">Test</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>事实上，这是可以编译通过的，那么这样做有什么意义呢？如何实例化这个类？我们知道，私有方法只能在类内调用，既然构造方法是私有的，在没有实例的情况下如何进入这个类的内部呢？</p>

<p>答案已经显而易见了，我们可以创建一个公有静态方法来调用：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">new</span> <span class="nf">Test</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="nf">Test</span><span class="o">()</span> <span class="o">{</span>

	<span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>这为我们实现简单的单例模式提供了思路，可以通过全局的静态方法控制实例的数量。如果在 <code class="highlighter-rouge">Intellij</code> 中选择创建一个单例模式的类，会得到如下模板：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleSingleton</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="nf">SimpleSingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
	
<span class="o">}</span>
</code></pre>
</div>

<p>似乎已经完美解决了问题！但是，如果你对 <code class="highlighter-rouge">Java类加载机制</code> 有一定了解，就会知道 static 代码在类加载的时候就会被执行，如果不巧初始化过程十分耗费时间，而这个实例被创建后又始终未使用，将形成浪费。</p>

<h2 id="懒汉模式与饿汉模式">懒汉模式与饿汉模式</h2>
<p>前面提到的方法被称作 <code class="highlighter-rouge">饿汉模式</code>，即：</p>

<blockquote>
  <p>无论实例何时使用以及是否被使用，总是急切的在类加载时就创建实例。</p>
</blockquote>

<p>与之相对，还有另外一种实现方法：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleSingleton</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>                   <span class="c1">// a</span>
		    <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>   <span class="c1">// b</span>

		<span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="nf">SimpleSingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>这被称作 <code class="highlighter-rouge">懒汉模式</code>：</p>

<blockquote>
  <p>只在第一次请求实例的时候进行创建，之后直接返回已创建的实例。</p>
</blockquote>

<h2 id="线程安全">线程安全</h2>
<p>懒汉模式虽然实现了延迟加载，但却有一个致命的问题：它是线程不安全的。对于上面的代码，如果有如下的调用顺序，将产生两个不同的实例：</p>

<ol>
  <li>线程1进入 getInstance() 方法，通过 [a] 处的 if 判断，在执行 [b] 处之前，时间片结束。</li>
  <li>线程2进入 getInstance() 方法，此时 ourInstance 仍旧为 null，线程2通过 if 判断，执行 [b] 处代码，创建新的 SimpleSigleton 实例，并返回。</li>
  <li>线程1执行 [b] 处代码，创建新的 SimpleSingleton 实例，这将覆盖线程2创建的实例，并返回新的实例。</li>
</ol>

<p>为了解决这个问题，可以使用 Java 的 <code class="highlighter-rouge">同步（加锁）</code> 机制：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span>  <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>

	<span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>被 <code class="highlighter-rouge">synchronized</code> 修饰的方法可以保证在同一时间只有一个线程能访问这个方法，这实现了线程安全，但却带来了 <code class="highlighter-rouge">性能</code> 上的问题：Java 在处理同步方法时需要进行加锁、解锁操作，这将耗费一定资源以及时间。</p>

<p>事实上，分析这段代码可以发现，只有在第一次创建实例的时候需要同步，之后直接返回已经创建的实例就可以了。如果在实际应用时需要多次访问这个函数，除了第一次访问之外的同步操作都是无意义的。</p>

<h2 id="双重检查锁定">双重检查锁定</h2>
<p>为了实现线程安全，同时解决效率问题，有人提出了更复杂的解决方案，即使用双重检查锁定：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span>  <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="kd">synchronized</span> <span class="o">(</span><span class="n">SimpleSingleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>因为只有创建实例这一条语句需要锁定，改为采用同步代码块而不是同步整个方法，这样只有未被实例化的情况下访问才进行同步操作，提高了性能。</p>

<p>同时为了避免懒汉模式中遇到的问题，在同步操作后再次检查 ourInstance 是否已被实例化。由于同一时间只有一个线程可以进入同步代码块，这保证了只有一个实例被创建。</p>

<p>*注意：由于是静态方法，同步块锁定的是整个类。</p>

<h2 id="jvm-带来的问题">JVM 带来的问题</h2>
<p>双重检查锁定看似已经很完美了，但很遗憾，实际使用时依然会出现问题。这是因为 JVM 允许编译器对指令进行 <code class="highlighter-rouge">重排序</code>，将无法保证 <code class="highlighter-rouge">有序性</code>。这里涉及到更深入的分析，我不打算在这篇文章继续讨论，因此只给出一个结论：</p>

<blockquote>
  <p>在 <code class="highlighter-rouge">new</code> 操作完成之前，编译器可能提前将等号左端的引用变为 <code class="highlighter-rouge">非空</code>。在多线程环境下，这将返回一个 <code class="highlighter-rouge">未完全初始化</code> 的对象。</p>
</blockquote>

<p>这看起来很荒唐，但却是真实存在的。幸运的是，Java 也提供了一种机制来解决这个问题：<code class="highlighter-rouge">volatile</code> 关键字。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleSingleton</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="n">SimpleSingleton</span> <span class="n">ourInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">// a</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span>  <span class="n">SimpleSingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="kd">synchronized</span> <span class="o">(</span><span class="n">SimpleSingleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">ourInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">ourInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleSingleton</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">return</span> <span class="n">ourInstance</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="nf">SimpleSingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>注意 [a] 处，我们为 ourInstance 加上了 <code class="highlighter-rouge">volatile</code> 关键字，关于它的具体作用，我（应该）会在另一篇文章讨论，这里只需要知道，volatile <code class="highlighter-rouge">禁止 Java 进行指令重排序</code>，这样，就可以实现一个线程安全的单例模式。</p>

	
</div>

		
		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/dontsay_lazy"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/hao-cui-3ab90214b"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
