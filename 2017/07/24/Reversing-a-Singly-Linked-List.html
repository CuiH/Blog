<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Reversing a Singly Linked List</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">Reversing a Singly Linked List</div>
	<span class="post-date">
		<time>24 Jul 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#algorithm">
					<span>algorithm</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="overview">Overview</h2>
<p>There are five common ways to reverse a singly linked list. I will introduce them one by one. The class <code class="highlighter-rouge">Node</code> is defined as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
    
    <span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="with-the-help-of-an-array">With the Help of an Array</h2>
<p>If we traverse the linked list and store every node inside a <code class="highlighter-rouge">ramdomly accessible</code> data structure, such as an array, we can then traverse the array reversely, constructing a new linked list. Since this is the simplest solution, I’m not gonna talk more about it, so here’s the code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList1</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously, the biggest problem of this solution is that it costs too much <code class="highlighter-rouge">space</code>, because we need o construct a data structure with the same length as the original linked list.</p>

<h2 id="continuously-reversing-the-pointer-between-every-two-nodes">Continuously Reversing the Pointer Between Every Two Nodes</h2>
<p>If we keep reversing every pointer between every two nodes, we’ll finally get a reversed linked list. The algorithm description is:</p>

<ul>
  <li>Define variables <code class="highlighter-rouge">currHead</code>, <code class="highlighter-rouge">next</code>, pointing to the head of current list, and the next node of current head; define variable <code class="highlighter-rouge">temp</code> for storing temporary nodes.</li>
  <li>First, set <code class="highlighter-rouge">currHead.next</code> to null.</li>
  <li>Enter the loop.</li>
  <li><code class="highlighter-rouge">temp</code> points to the next node of <code class="highlighter-rouge">next</code>.</li>
  <li>Set <code class="highlighter-rouge">next.next</code> to <code class="highlighter-rouge">currHead</code>.</li>
  <li>Move forward. <code class="highlighter-rouge">currHead</code> points to next; <code class="highlighter-rouge">next</code> points to <code class="highlighter-rouge">temp</code></li>
  <li>Loop until <code class="highlighter-rouge">next</code> points to null.</li>
  <li><code class="highlighter-rouge">currHead</code> is the head of the reversed list.</li>
</ul>

<p>Perhaps an example can help you understand this algorithm. Say we have a linked list <code class="highlighter-rouge">1 -&gt; 2-&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>:</p>

<ol>
  <li>
    <p>The original list
<img src="/assets/images/0905/2-0.png" alt="" /></p>
  </li>
  <li>
    <p>Initialization
<img src="/assets/images/0905/2-1.png" alt="" /></p>
  </li>
  <li>
    <p>Enter the loop
<img src="/assets/images/0905/2-2.png" alt="" /></p>
  </li>
  <li>
    <p>Reverse the pointer between the first two nodes
<img src="/assets/images/0905/2-3.png" alt="" /></p>
  </li>
  <li>
    <p>Move forward
<img src="/assets/images/0905/2-4.png" alt="" /></p>
  </li>
  <li>
    <p>Begin the second loop
<img src="/assets/images/0905/2-5.png" alt="" /></p>
  </li>
  <li>
    <p>Loop until <code class="highlighter-rouge">next</code> points to <code class="highlighter-rouge">null</code>
<img src="/assets/images/0905/2-6.png" alt="" /></p>
  </li>
</ol>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList2</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">currHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

    <span class="n">currHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="n">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">;</span>

        <span class="n">currHead</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">currHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="continuously-moving-nodes-from-the-original-list-to-the-head-of-the-new-list">Continuously Moving Nodes From the Original List to the Head of the New List</h2>
<p>This is another easy solution. What we should do is to add every node from the original list to the head of the new list. Also the example of <code class="highlighter-rouge">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>:</p>

<ol>
  <li>
    <p>Initialization: <code class="highlighter-rouge">newHead</code> points to <code class="highlighter-rouge">null</code>, <code class="highlighter-rouge">head</code> points to the head of the original list
<img src="/assets/images/0905/3-0.png" alt="" /></p>
  </li>
  <li>
    <p>Enter the loop: <code class="highlighter-rouge">temp</code> points to the next node of <code class="highlighter-rouge">head</code>; set <code class="highlighter-rouge">head.next</code> to <code class="highlighter-rouge">newHead</code>
<img src="/assets/images/0905/3-1.png" alt="" /></p>
  </li>
  <li>
    <p>Move forward: <code class="highlighter-rouge">newHead</code> points to <code class="highlighter-rouge">head</code>; <code class="highlighter-rouge">head</code> points to <code class="highlighter-rouge">temp</code>
<img src="/assets/images/0905/3-2.png" alt="" /></p>
  </li>
  <li>
    <p>Begin the next loop
<img src="/assets/images/0905/3-3.png" alt="" /></p>
  </li>
  <li>
    <p>Loop until <code class="highlighter-rouge">head</code> points to <code class="highlighter-rouge">null</code>. Now <code class="highlighter-rouge">newHead</code> points to the head of the reversed list
<img src="/assets/images/0905/3-4.png" alt="" /></p>
  </li>
</ol>

<p>The code is here:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList3</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>

        <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="continuously-inserting-the-next-node-of-the-head-of-original-list-after-the-head-of-the-new-list">Continuously Inserting the Next Node of the Head of Original List After the Head of the New List</h2>
<p>We need to construct a <code class="highlighter-rouge">helper node</code> in this case, and link it to the head of the original list. Then we keep inserting the <code class="highlighter-rouge">next node of the original list</code> after the <code class="highlighter-rouge">helper node</code>, until the next node of the original list is <code class="highlighter-rouge">null</code>. Now the <code class="highlighter-rouge">next node of the helper node</code> is the head of the reversed list. The algorithm is like:</p>

<ol>
  <li>
    <p>Initialization: Construct the helper node <code class="highlighter-rouge">newHead</code>, and link it to the head of the original list
<img src="/assets/images/0905/4-0.png" alt="" /></p>
  </li>
  <li>
    <p>Enter the loop: <code class="highlighter-rouge">temp</code> points to the next node of <code class="highlighter-rouge">head</code>
<img src="/assets/images/0905/4-1.png" alt="" /></p>
  </li>
  <li>
    <p>Insertion: set <code class="highlighter-rouge">head.next</code> to the next node of <code class="highlighter-rouge">temp</code>; set <code class="highlighter-rouge">temp.next</code> to the next node of <code class="highlighter-rouge">newHead</code>; set <code class="highlighter-rouge">newHead.next</code> to <code class="highlighter-rouge">temp</code>. Now we have inserted the next node of <code class="highlighter-rouge">head</code> to the position right after the <code class="highlighter-rouge">newHead</code>
<img src="/assets/images/0905/4-2.png" alt="" /></p>
  </li>
  <li>
    <p>Begin the next loop, and operate like process #2 and process #3
<img src="/assets/images/0905/4-3.png" alt="" /></p>
  </li>
  <li>
    <p>Loop until the next node of <code class="highlighter-rouge">head</code> is <code class="highlighter-rouge">null</code>. Now the next node of <code class="highlighter-rouge">newHead</code> is the head of the reversed list
<img src="/assets/images/0905/4-4.png" alt="" /></p>
  </li>
</ol>

<p>The key point of the algorithm is that, <code class="highlighter-rouge">newHead</code> and <code class="highlighter-rouge">head</code> always point to the same nodes, and what do is to move the node after the <code class="highlighter-rouge">head</code> to the next position of <code class="highlighter-rouge">newHead</code>. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList4</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">|</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="recursion">Recursion</h2>
<p>In fact, we can also reverse a linked list with recursion, the advantage of which is short code, but maybe it’s not that simple to understand.</p>

<p>The thinking is:</p>

<ol>
  <li>As for list <code class="highlighter-rouge">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>, we reverse <code class="highlighter-rouge">2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code> first, and then add <code class="highlighter-rouge">1</code> to the tail of the new list.</li>
  <li>As for list <code class="highlighter-rouge">2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>, we reverse <code class="highlighter-rouge">3 -&gt; 4 -&gt; 5 -&gt; null</code> first, and then add <code class="highlighter-rouge">2</code> to the tail of the new list.</li>
  <li>Recur until only one node left, <code class="highlighter-rouge">5</code>, and directly return this node.</li>
</ol>

<p>We should be aware that the recrusive method finally returns the tail of the reversed list, so to obtain its head, we may need a member variable. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Node</span> <span class="n">newHead</span><span class="o">;</span>

<span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList5</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">reverseRecursively</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Node</span> <span class="nf">reverseRecursively</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Node</span> <span class="n">tail</span>  <span class="o">=</span> <span class="n">reverseRecursively</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
    <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="an-example-on-leetcode">An example on Leetcode</h2>
<p>There are many peoblems regarding linked lists. Here I choose the <code class="highlighter-rouge">#25 Reverse Nodes in k-Group</code>, with the description:</p>

<blockquote>
  <p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>

  <p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>

  <p>You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed.</p>

  <p>For example, given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>

  <p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>

  <p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>

<p>This problem requires the given list to be reversed in groups of k nodes, and if the number of the remaining nodes is less than k, we should just keep the original order. Here I use the fourth method to handle it, that is, continuously inserting the next node of the original list after the head of the new list. The difference is that we need to judge before reversing, to check whether we have enough nodes left, and to record the beginning node of the next group as a stop signal. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseKGroup</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

    <span class="n">ListNode</span> <span class="n">currHead</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>    <span class="c1">// the head of curr group &amp; the tail of prev group</span>
    <span class="n">ListNode</span> <span class="n">nextHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>       <span class="c1">// the real head of next group</span>
    <span class="n">ListNode</span> <span class="n">temp</span><span class="o">;</span>                  <span class="c1">// stores the next node of currHead</span>

    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                     <span class="c1">// to find nextHead</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextHead</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>   <span class="c1">// no enough nodes left</span>

            <span class="n">nextHead</span> <span class="o">=</span> <span class="n">nextHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">head</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>              <span class="c1">// the real head of current group</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">nextHead</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">currHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">currHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="总览">总览</h2>
<p>常见的对单链表进行翻转有5种方法，下面将分别介绍。其中，类 <code class="highlighter-rouge">Node</code> 的定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

	<span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
	
	<span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="使用数组存储">使用数组存储</h2>
<p>遍历单链表，并将其存储在可 <code class="highlighter-rouge">随机访问</code> 的数据结构（如数组）中，随后反向遍历该数据结构，构建新的链表。由于最简单，不多做介绍，直接给出代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList1</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>很明显，这个代码最大的问题就是空间代价太大，需要建立一个与链表等长的数据结构。</p>

<h2 id="不断翻转每两个节点之间的指向">不断翻转每两个节点之间的指向</h2>
<p>如果把相邻两个节点的指向逐一翻转，最终将实现对整个链表的翻转，描述如下：</p>

<ul>
  <li>定义 <code class="highlighter-rouge">currHead</code>，<code class="highlighter-rouge">next</code> 两个变量，分别指向当前链表的头以及头的下一个节点；额外定义变量 <code class="highlighter-rouge">temp</code> 用于临时储存节点。</li>
  <li>首先将 <code class="highlighter-rouge">currHead</code> （省略“指向的”，下同）节点的下一个节点指向 <code class="highlighter-rouge">null</code>。</li>
  <li>进入循环。</li>
  <li>将 <code class="highlighter-rouge">temp</code> 指向 <code class="highlighter-rouge">next</code> 节点的下一个节点。</li>
  <li>将 <code class="highlighter-rouge">next</code> 节点的下一个节点指向 <code class="highlighter-rouge">currHead</code> 节点。</li>
  <li>将 <code class="highlighter-rouge">currHead</code> 指向 <code class="highlighter-rouge">next</code> 节点；将 <code class="highlighter-rouge">next</code> 指向 <code class="highlighter-rouge">temp</code> 节点。</li>
  <li>循环直至 <code class="highlighter-rouge">next</code> 节点 为 <code class="highlighter-rouge">null</code>。</li>
  <li><code class="highlighter-rouge">currHead</code> 节点即为翻转后链表的头。</li>
</ul>

<p>用具体的例子可能更方便理解。假设有链表 <code class="highlighter-rouge">1 -&gt; 2-&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，翻转过程如下：</p>

<ol>
  <li>
    <p>初始链表
<img src="/assets/images/0905/2-0.png" alt="" /></p>
  </li>
  <li>
    <p>初始化
<img src="/assets/images/0905/2-1.png" alt="" /></p>
  </li>
  <li>
    <p>进入循环
<img src="/assets/images/0905/2-2.png" alt="" /></p>
  </li>
  <li>
    <p>翻转前两个节点的指向
<img src="/assets/images/0905/2-3.png" alt="" /></p>
  </li>
  <li>
    <p>向前移动
<img src="/assets/images/0905/2-4.png" alt="" /></p>
  </li>
  <li>
    <p>开始第二次循环
<img src="/assets/images/0905/2-5.png" alt="" /></p>
  </li>
  <li>
    <p>继续循环直至 <code class="highlighter-rouge">next</code> 指向 <code class="highlighter-rouge">null</code>，此时 <code class="highlighter-rouge">currHead</code> 指向翻转后的节点头
<img src="/assets/images/0905/2-6.png" alt="" /></p>
  </li>
</ol>

<p>代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList2</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">currHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

	<span class="n">currHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

		<span class="n">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">;</span>

		<span class="n">currHead</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">currHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="不断将原链表的节点放到新链表的头部">不断将原链表的节点放到新链表的头部</h2>
<p>这种方法思路和实现都不难，只需将原链表的节点逐一添加到新链表的头部即可。还是 <code class="highlighter-rouge">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code> 的例子，翻转过程的描述和示例一起展示如下：</p>

<ol>
  <li>
    <p>初始化：<code class="highlighter-rouge">newHead</code> 指向 <code class="highlighter-rouge">null</code>，<code class="highlighter-rouge">head</code> 指向原链表的头
<img src="/assets/images/0905/3-0.png" alt="" /></p>
  </li>
  <li>
    <p>进入循环：将 <code class="highlighter-rouge">temp</code> 指向 <code class="highlighter-rouge">head</code> 节点的下一个节点；将 <code class="highlighter-rouge">head</code> 节点的下一个节点指向 <code class="highlighter-rouge">newHead</code> 节点
<img src="/assets/images/0905/3-1.png" alt="" /></p>
  </li>
  <li>
    <p>向前移动：将 <code class="highlighter-rouge">newHead</code> 指向 <code class="highlighter-rouge">head</code> 节点；将 <code class="highlighter-rouge">head</code> 指向 <code class="highlighter-rouge">temp</code> 节点
<img src="/assets/images/0905/3-2.png" alt="" /></p>
  </li>
  <li>
    <p>进入下一次循环
<img src="/assets/images/0905/3-3.png" alt="" /></p>
  </li>
  <li>
    <p>循环直至 <code class="highlighter-rouge">head</code> 指向 <code class="highlighter-rouge">null</code>，此时 <code class="highlighter-rouge">newHead</code> 指向翻转后的链表头
<img src="/assets/images/0905/3-4.png" alt="" /></p>
  </li>
</ol>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList3</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

		<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>

		<span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="不断将原链表头的下一个节点插入新链表头之后">不断将原链表头的下一个节点插入新链表头之后</h2>
<p>使用这个方法需要构造一个辅助节点，链接到原链表头之前，随后不断将原链表头的 <code class="highlighter-rouge">下一个节点</code> 插入到辅助节点之后，直至原链表头的下一个节点为 <code class="highlighter-rouge">null</code>，此时辅助节点的下一个节点即为翻转后链表的头。算法描述及示例如下：</p>

<ol>
  <li>
    <p>初始化：构造辅助节点 <code class="highlighter-rouge">newHead</code>，链接到原链表头
<img src="/assets/images/0905/4-0.png" alt="" /></p>
  </li>
  <li>
    <p>进入循环：将 <code class="highlighter-rouge">temp</code> 指向 <code class="highlighter-rouge">head</code> 节点的下一个节点
<img src="/assets/images/0905/4-1.png" alt="" /></p>
  </li>
  <li>
    <p>插入：将 <code class="highlighter-rouge">head</code> 节点的下一个节点指向 <code class="highlighter-rouge">temp</code> 节点的下一个节点；将 <code class="highlighter-rouge">temp</code> 节点的下一个节点指向 <code class="highlighter-rouge">newHead</code> 节点的下一个节点；将 <code class="highlighter-rouge">newHead</code> 节点的下一个节点指向 <code class="highlighter-rouge">temp</code> 节点。这样就将 <code class="highlighter-rouge">head</code> 节点的下一个节点插入到新链表头之后
<img src="/assets/images/0905/4-2.png" alt="" /></p>
  </li>
  <li>
    <p>进入下一轮循环，操作同步骤2、3
<img src="/assets/images/0905/4-3.png" alt="" /></p>
  </li>
  <li>
    <p>循环直至 <code class="highlighter-rouge">head</code> 节点的下一个节点为 <code class="highlighter-rouge">null</code>，此时 <code class="highlighter-rouge">newHead</code> 节点的下一个节点为翻转后链表的头
<img src="/assets/images/0905/4-4.png" alt="" /></p>
  </li>
</ol>

<p>这个算法的关键在于，<code class="highlighter-rouge">newHead</code> 和 <code class="highlighter-rouge">head</code> 所指向的节点是不变的，只是不断将 <code class="highlighter-rouge">head</code> 节点之后的节点移到 <code class="highlighter-rouge">newHead</code> 节点之后。实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList4</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">|</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
	<span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

		<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="递归实现">递归实现</h2>
<p>事实上也可以用递归来实现链表的翻转，优势是代码短，但可能没有那么容易理解。</p>

<p>使用递归的思路是：</p>

<ol>
  <li>对与链表 <code class="highlighter-rouge">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，先翻转 <code class="highlighter-rouge">2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，再需将 <code class="highlighter-rouge">1</code> 添加到新链表的尾。</li>
  <li>对于链表 <code class="highlighter-rouge">2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，先翻转 <code class="highlighter-rouge">3 -&gt; 4 -&gt; 5 -&gt; null</code>，再将 <code class="highlighter-rouge">2</code> 添加到新链表的尾。</li>
  <li>递归直至只剩下一个节点 <code class="highlighter-rouge">5</code>，直接返回该节点。</li>
</ol>

<p>需要注意的是，递归函数最终返回的是翻转后链表的尾，为了获取新链表的头，可以使用一个类成员变量保存。</p>

<p>代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Node</span> <span class="n">newHead</span><span class="o">;</span>

<span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList5</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">reverseRecursively</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>

	<span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Node</span> <span class="nf">reverseRecursively</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

		<span class="k">return</span> <span class="n">head</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">Node</span> <span class="n">tail</span>  <span class="o">=</span> <span class="n">reverseRecursively</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
	<span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
	<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">return</span> <span class="n">head</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="leetcode-上的例子">Leetcode 上的例子</h2>
<p>Leetcode 上有很多关于链表的题目，这里选取 <code class="highlighter-rouge">#25 Reverse Nodes in k-Group</code>，题目描述如下：</p>

<blockquote>
  <p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>

  <p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>

  <p>You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed.</p>

  <p>For example,
Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5
For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5
For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>

<p>题目要求将链表每 k 个一组进行翻转，如果剩余不足 k 个则剩余部分维持原样。这里使用前面提到的第四种方法（不断将原链表头的下一个节点插入新链表头之后），只是需要在翻转前先判断剩余节点数，以及记录下下一组的起始节点作为停止条件。代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseKGroup</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">ListNode</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
	<span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">ListNode</span> <span class="n">currHead</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>    <span class="c1">// the head of curr group &amp; the tail of prev group</span>
	<span class="n">ListNode</span> <span class="n">nextHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>       <span class="c1">// the real head of next group</span>
	<span class="n">ListNode</span> <span class="n">temp</span><span class="o">;</span>                  <span class="c1">// stores the next node of currHead</span>

	<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>			           <span class="c1">// to find nextHead</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">nextHead</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>   <span class="c1">// no enough nodes left</span>

			<span class="n">nextHead</span> <span class="o">=</span> <span class="n">nextHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="n">head</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>              <span class="c1">// the real head of current group</span>

		<span class="k">while</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">nextHead</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
			<span class="n">currHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="n">currHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

	
</div>

		
		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/dontsay_lazy"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/hao-cui-3ab90214b"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
