<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Binary Tree Traversals</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">Binary Tree Traversals</div>
	<span class="post-date">
		<time>04 Aug 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#algorithm">
					<span>algorithm</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="overview">Overview</h2>
<p>The <code class="highlighter-rouge">binary tree</code> is a very classical data structure, and we have various ways to perform preorder, inorder and postorder traversals on it. The class <code class="highlighter-rouge">TreeNode</code> used in this blog is defined as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="n">TreeNode</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">TreeNode</span> <span class="n">right</span><span class="o">;</span>

    <span class="n">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If there’s no special statement, we’ll use this tree in our examples:</p>

<p><img src="/assets/images/0907/0-0.png" alt="" /></p>

<h2 id="recursive-travesals">Recursive travesals</h2>
<p>This may be the simplest algorithm of traversing, so I just post the code here:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">preorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

    <span class="n">preorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
    <span class="n">preorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">inorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

    <span class="n">inorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">postorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
    <span class="n">postorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="traversing-with-a-stack">Traversing with a stack</h2>
<p>The key point of traversing a binary tree is how to go back to the parent node and traverse another child after we have traversed one child. Here we can use a <code class="highlighter-rouge">stack</code> to record visited nodes, and its <code class="highlighter-rouge">fitst-in-first-out</code> feature will perfectly help us go back to the parent after the traversing a subtree.</p>

<h3 id="preorder-traversal">Preorder traversal</h3>
<ol>
  <li>As for the current node, traverse along the <code class="highlighter-rouge">left child</code>, and keep outputing and pushing to the stack, until current node points to <code class="highlighter-rouge">null</code>.</li>
  <li>Pop the top node from the stack, and its <code class="highlighter-rouge">right child</code> will become the current node.</li>
  <li>Repeat process #1 and #2, until current node points to <code class="highlighter-rouge">null</code> and the stack is empty.</li>
</ol>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">preorderWithStack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span><span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="inorder-traversal">Inorder traversal</h3>
<p>The thinking is similar to the preorder one, but this time we output at the time of popping (from stack). Here’s the code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">inorderWithStack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span><span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="postorder-traversal">Postorder traversal</h3>
<p>This could be a little bit complicate. The point is, we should ensure that the parent node is not outputed until all of his children are traversed. A common method is to remember the last outputed node. Here are three possible ideas.</p>

<p>a) Just like the previous solution:</p>

<p>Similar to the preorder and inorder traversal code above. The difference is we record the last outputed node, and before popping the stack, we check whether both children of the top node in the stack have been traversed (or, is <code class="highlighter-rouge">null</code>), by comparing them with the recorded node:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithStack1</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">prev</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

            <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>b) Another method:</p>

<ol>
  <li>Push the current node (root) into the stack.</li>
  <li>Get the top node of the stack. If its children are all <code class="highlighter-rouge">null</code>, or have been traversed (that is, one of them is the last outputed node), pop it and outout it; otherwise push its <code class="highlighter-rouge">right</code> child into the stack (if it is not <code class="highlighter-rouge">null</code>), and then its <code class="highlighter-rouge">left</code> node (if it is not <code class="highlighter-rouge">null</code>).</li>
  <li>Repeat process #2, until the stack becomes empty.</li>
</ol>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithStack2</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
 
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="n">prev</span> <span class="o">||</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">prev</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>c) Using two stacks</p>

<p>This method is somewhat interesting. We know that the sequence of postorder traversal is <code class="highlighter-rouge">left -&gt; right -&gt; mid</code>. What if we traverse by <code class="highlighter-rouge">mid -&gt; right -&gt; left</code> and then reverse the result? We can do this with two stacks, traversing with one stack, and outputing the result to another stack, and finally popping nodes from the second stack one by one to get the postorder traversal:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithTwoStacks</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">resStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">resStack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">resStack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">resStack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="level-traversal">Level Traversal</h2>
<p>In some cases, we want to traverse a binary tree level by level. Obviously, using <code class="highlighter-rouge">queue</code> is a good choice. It’s simple so I only post the code here:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">levelTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="morris-traversal">Morris Traversal</h2>
<p>The average space complexity of all of the algorithms above, except the recursive ones and the two-stack solution, is <code class="highlighter-rouge">O(logn)</code>. Is there any binary tree traversal algorithm that consumes only <code class="highlighter-rouge">O(1)</code> space? The answer is “yes”.
Such method is called the <code class="highlighter-rouge">Morris Traversal</code>. Here is the description of the <code class="highlighter-rouge">inorder</code> one：</p>

<ol>
  <li>If the <code class="highlighter-rouge">left</code> child of current node is <code class="highlighter-rouge">null</code>, output it, and then traverse its <code class="highlighter-rouge">right</code> child.</li>
  <li>If the <code class="highlighter-rouge">left</code> child is not <code class="highlighter-rouge">null</code>, find the inorder <code class="highlighter-rouge">predecessor</code> in its left subtree. If the <code class="highlighter-rouge">right</code> child of the predecessor is <code class="highlighter-rouge">null</code>, point it to the current node, and then traverse the left child of the current node; if the right child of the predecessor is current node, revert it to <code class="highlighter-rouge">null</code>, and output current node, and then traverse the right node of the current node.</li>
  <li>Repeat process #1 and #2, until the currrent node points to <code class="highlighter-rouge">null</code>.</li>
</ol>

<p>Here it involves a concept, called the <code class="highlighter-rouge">inorder predecessor</code>:</p>

<blockquote>
  <p>Given a node, the node before it in the inorder traversal is its inorder predecessor.</p>
</blockquote>

<p>The common way to find it is to continuously go <code class="highlighter-rouge">right</code> in the <code class="highlighter-rouge">left</code> subtree of a node, until the right child is <code class="highlighter-rouge">null</code>.</p>

<p>The ingenuity of this algorithm is that we utilize the empty space <code class="highlighter-rouge">inside</code> the tree to help us go back to the parent node, without any extra space. When we traverse the left subtree of a node, we first save current node in the right child of its predecessor. After we finish the traversal of the left subtree (and arrive at the predecessor), according to the algorithm we will go to the right child of the last node (because its left child is <code class="highlighter-rouge">null</code>) and thus successfully come back to the parent! Then, at the parent node, we find the right child of its predecessor is <code class="highlighter-rouge">itselt</code>, which means the left subtree has been traversed, so we move to the right subtree.</p>

<p>As for our example, a detailed description is:</p>

<ol>
  <li>
    <p>The original tree.
<img src="/assets/images/0907/T-0.png" alt="" /></p>
  </li>
  <li>
    <p>Find the predecessor and change its right child, and then traverse the left subtree of current node.
<img src="/assets/images/0907/T-1.png" alt="" /></p>
  </li>
  <li>
    <p>The same as above.
<img src="/assets/images/0907/T-2.png" alt="" /></p>
  </li>
  <li>
    <p>The left child is <code class="highlighter-rouge">null</code>, so output current node.
<img src="/assets/images/0907/T-3.png" alt="" /></p>
  </li>
  <li>
    <p>Traverse the right subtree, and come back to the parent.
<img src="/assets/images/0907/T-4.png" alt="" /></p>
  </li>
  <li>
    <p>The right child of the predecessor is self, so revert it and output current node. Traverse the right subtree.
<img src="/assets/images/0907/T-5.png" alt="" /></p>
  </li>
  <li>
    <p>Handle the predecessor, and traverse the left subtree.
<img src="/assets/images/0907/T-6.png" alt="" /></p>
  </li>
  <li>
    <p>The left child is null, so output current node. Traverse the right subtree, and come back to the parent.
<img src="/assets/images/0907/T-7.png" alt="" /></p>
  </li>
  <li>
    <p>The right child of the predecessor is self, so revert it and output current node. Traverse the right subtree and come back to the parent.
<img src="/assets/images/0907/T-8.png" alt="" /></p>
  </li>
  <li>
    <p>The right child of the predecessor is self, so revert it and output current node. Traverse the right subtree.
<img src="/assets/images/0907/T-9.png" alt="" /></p>
  </li>
  <li>
    <p>The left child is <code class="highlighter-rouge">null</code>, so output current node, and traverse the right subtree.
<img src="/assets/images/0907/T-10.png" alt="" /></p>
  </li>
  <li>
    <p>The same as above. Finsh the traversal.
<img src="/assets/images/0907/T-11.png" alt="" /></p>
  </li>
</ol>

<p>Here’s the code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">morrisInorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">TreeNode</span> <span class="n">predecessor</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="n">root</span><span class="o">)</span>
                <span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

	
</div>

		
		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/dontsay_lazy"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/hao-cui-3ab90214b"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
