<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>对 Java 内存模型的理解</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">对 Java 内存模型的理解</div>
	<span class="post-date">
		<time>03 Sep 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#java">
					<span>java</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="什么是jvm">什么是JVM</h2>
<p>Java 一个很重要的特性是与平台无关性，而这正是靠 JVM 来实现的。JVM 用有自己的指令集、寄存器等，屏蔽了底层操作系统的相关信息。Java 程序在编译时只需生成 JVM 能读懂的字节码，运行时 JVM 根据不同操作系统生成相应的机器指令执行。</p>

<h2 id="jvm的结构">JVM的结构</h2>
<p>JVM 在执行 Java 程序的时候，其内存主要分为如下几个区域：</p>

<ul>
  <li>方法区 Method Area：存储加载的类信息，以及类中 static 变量等，是 GC 中的持久代区，同时是 <code class="highlighter-rouge">线程共享</code> 的。</li>
  <li>常量池 Constant Pool：存储类中的 final 常量，类名、方法名等，是编译期就已经确定的。</li>
  <li>程序计数器 Program Counter Register：每个 <code class="highlighter-rouge">线程独立</code> 拥有，存储当前执行的指令的内存地址。</li>
  <li>本地方法栈 Native Method Stack：为 native 方法服务。</li>
  <li>栈 Stack：每个线程拥有自己的栈，每个方法拥有自己的栈帧，其中存储一些 <code class="highlighter-rouge">基本数据类型变量</code> （如int，boolean），<code class="highlighter-rouge">非基本类型变量在堆中的地址引用</code>，以及返回值信息等。栈顶指向当前活动的栈帧（即方法帧）。</li>
  <li>堆 Heap：JVM 管理的内存中最大的一块区域，<code class="highlighter-rouge">线程共享</code>，所有由 <code class="highlighter-rouge">new</code> 操作创建的对象的内存在此分配（包括对象实例、数组等）。是 <code class="highlighter-rouge">GC</code> 的主要活动区域。</li>
</ul>

<h2 id="java-的内存分配">Java 的内存分配</h2>
<p>总的来说，Java 对于基本数据类型以及对象的内存分配的处理是不同的：</p>

<ul>
  <li>基本数据类型：包括 byte, short, int, long, float, double, boolean, char。当在方法中定义这些变量时，JVM 会在线程栈中为它们直接分配存储空间。当变量超过其作用域时，空间被释放。</li>
  <li>由 <code class="highlighter-rouge">new</code> 创建的对象以及数组：在堆中分配存储空间，而在方法中产生的对这些 <code class="highlighter-rouge">对象的引用</code> 存储在栈中。如果一个对象没有任何引用指向它，它所占的空间不会立即被释放，而是等待某个特定的时间由 GC 进行释放。</li>
</ul>

<h2 id="java-的栈内存堆内存与参数传递">Java 的栈内存、堆内存与参数传递</h2>
<p>不同于 C++，Java 中没有指针这一概念，对象在堆中创建，程序在栈中执行，因此操作的始终是 <code class="highlighter-rouge">对象的引用</code>，比如，下面这段程序：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
		<span class="n">a1</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  <span class="c1">// 5</span>

		<span class="n">update</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  <span class="c1">// 8</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">A</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">a2</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">update()</code> 函数的参数 <code class="highlighter-rouge">a2</code> 接收了对象的引用，运行时 JVM 根据引用的地址在堆中找到这个对象，并对其 <code class="highlighter-rouge">value</code> 成员变量进行修改。由于堆内存是全局共享的，这个修改对 <code class="highlighter-rouge">main()</code> 函数中对象的另一个引用 <code class="highlighter-rouge">a1</code> 立即可见，因此两次输出的结果不同。</p>

<p>对于上面的例子，如果我们将 A 换为一个基本数据类型，如 int，则结果完全不同。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>  <span class="c1">// 5</span>

		<span class="n">update</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>  <span class="c1">// 5</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">a2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>JVM 中的栈相对于堆存取速度更快，所以对于生存期已知、大小已知的基本数据类型，直接在栈中为其分配空间。</p>

<p>*注意： 如果使用了 Java 的包装类 <code class="highlighter-rouge">Integer</code>，或者是基本类型的数组如 <code class="highlighter-rouge">int[]</code>，则结果与第一个例子相同，因此主要的区分方法是：是否使用 <code class="highlighter-rouge">new</code> 操作符进行创建。</p>

<h2 id="特殊的数据类型string">特殊的数据类型：String</h2>
<p>你应该注意到，前面提到的 Java 中八种基本数据类型没有包括 String，但是请看下面的例子：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"test"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"test"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>似乎 Stirng 表现出与基本数据类型的一样的特性，这是因为 JVM 对 String 进行了特殊的处理。前面提到的 JVM 内存区域中的 <code class="highlighter-rouge">常量池</code> 中有一部分为 <code class="highlighter-rouge">字符串常量池</code> ，在创建字符串时，JVM 首先在这个池中寻找是否存在同字面的字符串，如果存在，返回这个对象的引用，若不存在，则创建新的字符串常量。</p>

<p>再来回答一个十分经典的问题：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
</code></pre>
</div>

<p>这行代码创建了几个对象？答案是两个，首先在字符创常量池中创建 <code class="highlighter-rouge">"test"</code>,由于使用了 <code class="highlighter-rouge">new</code> 操作符，再在堆中创建新的 <code class="highlighter-rouge">String</code> 对象。</p>

<p>如果你理解了前面的内容，下面语句的结果就显而易见了：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// false</span>
</code></pre>
</div>

<p>这里引申一句题外话，Java 中的 <code class="highlighter-rouge">==</code> 操作符比较的是变量引用的地址，因此对于对象不能直接使用 <code class="highlighter-rouge">==</code> 进行比较。如果只是比较 String 的字面值，可以使用其自带的 <code class="highlighter-rouge">equals()</code> 函数：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>另外，Java 更推荐直接使用字符串常量池创建字符串，而不是通过 <code class="highlighter-rouge">new</code> 操作符。</p>

<p>最后，我们来探讨一下编译器的有趣之处，看下面的例子：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"aaabbb"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"aaa"</span> <span class="o">+</span> <span class="s">"bbb"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>编译器似乎十分“聪明”，在编译期对我们的语句进行了一些优化。不过，编译器也没有那么“聪明”：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"aaa"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"bbb"</span><span class="o">;</span>

<span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">"aaabbb"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="o">);</span>   <span class="c1">// false</span>
</code></pre>
</div>

<p>如果在 <code class="highlighter-rouge">+</code> 操作符的两边存在非常量，即使连接后的字符串存在于常量池中，依旧会创建新的对象。</p>

	
</div>

		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/none"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/none"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
