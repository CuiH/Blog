<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Understanding of the Java Memory Model</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">Understanding of the Java Memory Model</div>
	<span class="post-date">
		<time>03 Sep 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#java">
					<span>java</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="what-is-java-virtual-machine-jvm">What is Java Virtual Machine (JVM)?</h2>
<p>One of the most important characteristics of Java is that it is <code class="highlighter-rouge">platform-independent</code>, which is fulfilled by the <code class="highlighter-rouge">JVM</code>. JVM has its own instruction sets and registers, so java codes can ignore the implementation of the underlying operating system, and only need to generate bytecodes that JVM can read. When running, JVM will convert the bytecode to native machine code of the host platform and then execute.</p>

<h2 id="the-structure-of-jvm">The Structure of JVM</h2>
<p>The memory of JVM consists mainly of the following areas:</p>

<ul>
  <li>Method Area: storing information of the loaded classes, along with those <code class="highlighter-rouge">static</code> variables. It is the <code class="highlighter-rouge">permanent generation</code> in <code class="highlighter-rouge">garbage collection (GC)</code>, and is <code class="highlighter-rouge">thread-sharing</code>.</li>
  <li>Constant Pool: storing <code class="highlighter-rouge">final</code> variables, class names, method names and values that can be determined at compile time.</li>
  <li>Program Countre Register: <code class="highlighter-rouge">thread-independent</code>, stroing the memory address of the instrucion that is currently being executed.</li>
  <li>Native Method Stack: serving <code class="highlighter-rouge">native</code> methods.</li>
  <li>Stack: each thread has its own <code class="highlighter-rouge">stack</code>, and each method has its own <code class="highlighter-rouge">thread frame</code>, storing <code class="highlighter-rouge">variables of basic data types</code> (such as int, boolean), and <code class="highlighter-rouge">references (addresses in heap) to instances of non-basic data typess</code>, as well as information of the return values. The top of the stack points to the current active stack (method) frame.</li>
  <li>Heap: the largest area tha JVM memory controls, ‘thread-sharing’. All memory of objects that are created by <code class="highlighter-rouge">new</code> operations are allocated here (including instances of objects and arrays). It is the main active region of <code class="highlighter-rouge">GC</code>.</li>
</ul>

<h2 id="the-memory-allocation-in-java">The Memory Allocation in Java</h2>
<p>In general, Java treats basic data types and objects differently in memory allocation:</p>

<ul>
  <li>Basic Date Types: including byte, short, int, long, float, double, boolean, char. When defining these variables in methods, JVM will directly allocate spaces for them in <code class="highlighter-rouge">thread stack</code>. If a variable is beyond its scope, it space will be released.</li>
  <li>Objects created by <code class="highlighter-rouge">new</code> operations (including arrays): Their spaces will be allocated in <code class="highlighter-rouge">heap</code>,  and a <code class="highlighter-rouge">reference to the address</code> will be created in stack if needed. If an object is not referenced by any variable, its space won’t be realeased immediately, but will be collected by GC at a <code class="highlighter-rouge">certain</code> time (decided by many factors).</li>
</ul>

<h2 id="stack-memory-heap-memory-and-parameter-passing">Stack Memory, Heap Memory and Parameter Passing</h2>
<p>Different from C++, there’s no <code class="highlighter-rouge">pointers</code> in Java. Objecets are created in heap, and programs are executed in stack, so we are operating the <code class="highlighter-rouge">reference to object</code> all the time. For example, let’s see the following program:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
        <span class="n">a1</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  <span class="c1">// 5</span>

        <span class="n">update</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  <span class="c1">// 8</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">A</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">a2</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>The parameter <code class="highlighter-rouge">a2</code> of method <code class="highlighter-rouge">update()</code> receives references to objects. When running, JVM finds this object in heap according to the address, and then modify its member variable <code class="highlighter-rouge">value</code>. Since the heap is shared, this modification is visible immediately to another reference <code class="highlighter-rouge">a1</code> in method <code class="highlighter-rouge">main()</code>, so the two outputs are different.</p>

<p>As for the above example, if we change the type A to a basic data type, such as <code class="highlighter-rouge">int</code>, the result will be totally different:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>  <span class="c1">// 5</span>

        <span class="n">update</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>  <span class="c1">// 5</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>In JVM, stack can be read and write much faster than heap, so for basic data types, whose life cycle and size are known at compile time, their spaces are allocated directly in stack.</p>

<p>*Attention: If you use Java’s <code class="highlighter-rouge">wrapper class</code> such as <code class="highlighter-rouge">Integer</code>, or arrays of basic data types such as <code class="highlighter-rouge">int[]</code>, the result will be same as the first example. Therefore, the most useful difference is: whether it uses a <code class="highlighter-rouge">new</code> operator to create.</p>

<h2 id="a-special-data-type-string">A Special Data Type: String</h2>
<p>You should notice that the eight basic data types mentioned above do not include <code class="highlighter-rouge">String</code>, but you don’t need to <code class="highlighter-rouge">new</code> a String, why? Let’s see an example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"test"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"test"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>It seems that String behaves just like basic data types. This is due to the fact that JVM treats String specially. The <code class="highlighter-rouge">Constant Pool</code> in the memory of JVM we mentioned includes a <code class="highlighter-rouge">String Constant Pool</code>, which will be searched first if we create a String. If there’s a String with the same <code class="highlighter-rouge">literal value</code>JVM will return its reference directly; if not, JVM creates a new String constant.</p>

<p>What about this classical question:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
</code></pre>
</div>

<p>How many objects are created in the code? The answer is <code class="highlighter-rouge">two</code>. First, a String <code class="highlighter-rouge">constant</code> is created in the String Constant Pool values <code class="highlighter-rouge">test</code>, and then since there’s a <code class="highlighter-rouge">new</code> operation, JVM creates a new String <code class="highlighter-rouge">object</code> in heap.</p>

<p>If you have understood all contents above, the results of the following code will be obvious:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// false</span>
</code></pre>
</div>

<p>Here we digress a little. the <code class="highlighter-rouge">==</code> operator in Java compares the references to objects (that is, the addresses). Therefore, we can’t directly use <code class="highlighter-rouge">==</code> to compare the literal values of two Strings, but we can use method ‘equals()’ instead:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>In addition, Java recommends creating String with String Constant Pool rather than <code class="highlighter-rouge">new</code> operator.</p>

<p>Finally, let’s discuss an interesting point of the compiler. Look at this example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"aaabbb"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"aaa"</span> <span class="o">+</span> <span class="s">"bbb"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>The compiler seems to be so <code class="highlighter-rouge">smart</code> that it makes some optimizations at compile time. However, the compiler is not that <code class="highlighter-rouge">smart</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"aaa"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"bbb"</span><span class="o">;</span>

<span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">"aaabbb"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="o">);</span>   <span class="c1">// false</span>
</code></pre>
</div>

<p>if there is non-constant value at either side (or both) of the <code class="highlighter-rouge">+</code> operator, a new String object will always be created, even if the concatenated String exists in the String Constant Pool.</p>

<hr />

<h2 id="什么是jvm">什么是JVM</h2>
<p>Java 一个很重要的特性是与平台无关性，而这正是靠 JVM 来实现的。JVM 用有自己的指令集、寄存器等，屏蔽了底层操作系统的相关信息。Java 程序在编译时只需生成 JVM 能读懂的字节码，运行时 JVM 根据不同操作系统生成相应的机器指令执行。</p>

<h2 id="jvm的结构">JVM的结构</h2>
<p>JVM 在执行 Java 程序的时候，其内存主要分为如下几个区域：</p>

<ul>
  <li>方法区 Method Area：存储加载的类信息，以及类中 static 变量等，是 GC 中的持久代区，同时是 <code class="highlighter-rouge">线程共享</code> 的。</li>
  <li>常量池 Constant Pool：存储类中的 final 常量，类名、方法名等，是编译期就已经确定的。</li>
  <li>程序计数器 Program Counter Register：每个 <code class="highlighter-rouge">线程独立</code> 拥有，存储当前执行的指令的内存地址。</li>
  <li>本地方法栈 Native Method Stack：为 native 方法服务。</li>
  <li>栈 Stack：每个线程拥有自己的栈，每个方法拥有自己的栈帧，其中存储一些 <code class="highlighter-rouge">基本数据类型变量</code> （如int，boolean），<code class="highlighter-rouge">非基本类型变量在堆中的地址引用</code>，以及返回值信息等。栈顶指向当前活动的栈帧（即方法帧）。</li>
  <li>堆 Heap：JVM 管理的内存中最大的一块区域，<code class="highlighter-rouge">线程共享</code>，所有由 <code class="highlighter-rouge">new</code> 操作创建的对象的内存在此分配（包括对象实例、数组等）。是 <code class="highlighter-rouge">GC</code> 的主要活动区域。</li>
</ul>

<h2 id="java-的内存分配">Java 的内存分配</h2>
<p>总的来说，Java 对于基本数据类型以及对象的内存分配的处理是不同的：</p>

<ul>
  <li>基本数据类型：包括 byte, short, int, long, float, double, boolean, char。当在方法中定义这些变量时，JVM 会在线程栈中为它们直接分配存储空间。当变量超过其作用域时，空间被释放。</li>
  <li>由 <code class="highlighter-rouge">new</code> 创建的对象以及数组：在堆中分配存储空间，而在方法中产生的对这些 <code class="highlighter-rouge">对象的引用</code> 存储在栈中。如果一个对象没有任何引用指向它，它所占的空间不会立即被释放，而是等待某个特定的时间由 GC 进行释放。</li>
</ul>

<h2 id="java-的栈内存堆内存与参数传递">Java 的栈内存、堆内存与参数传递</h2>
<p>不同于 C++，Java 中没有指针这一概念，对象在堆中创建，程序在栈中执行，因此操作的始终是 <code class="highlighter-rouge">对象的引用</code>，比如，下面这段程序：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">();</span>
		<span class="n">a1</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  <span class="c1">// 5</span>

		<span class="n">update</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  <span class="c1">// 8</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">A</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">a2</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">update()</code> 函数的参数 <code class="highlighter-rouge">a2</code> 接收了对象的引用，运行时 JVM 根据引用的地址在堆中找到这个对象，并对其 <code class="highlighter-rouge">value</code> 成员变量进行修改。由于堆内存是全局共享的，这个修改对 <code class="highlighter-rouge">main()</code> 函数中对象的另一个引用 <code class="highlighter-rouge">a1</code> 立即可见，因此两次输出的结果不同。</p>

<p>对于上面的例子，如果我们将 A 换为一个基本数据类型，如 int，则结果完全不同。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>  <span class="c1">// 5</span>

		<span class="n">update</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>

		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>  <span class="c1">// 5</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">a2</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<p>JVM 中的栈相对于堆存取速度更快，所以对于生存期已知、大小已知的基本数据类型，直接在栈中为其分配空间。</p>

<p>*注意： 如果使用了 Java 的包装类 <code class="highlighter-rouge">Integer</code>，或者是基本类型的数组如 <code class="highlighter-rouge">int[]</code>，则结果与第一个例子相同，因此主要的区分方法是：是否使用 <code class="highlighter-rouge">new</code> 操作符进行创建。</p>

<h2 id="特殊的数据类型string">特殊的数据类型：String</h2>
<p>你应该注意到，前面提到的 Java 中八种基本数据类型没有包括 String，但是请看下面的例子：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"test"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"test"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>似乎 Stirng 表现出与基本数据类型的一样的特性，这是因为 JVM 对 String 进行了特殊的处理。前面提到的 JVM 内存区域中的 <code class="highlighter-rouge">常量池</code> 中有一部分为 <code class="highlighter-rouge">字符串常量池</code> ，在创建字符串时，JVM 首先在这个池中寻找是否存在同字面的字符串，如果存在，返回这个对象的引用，若不存在，则创建新的字符串常量。</p>

<p>再来回答一个十分经典的问题：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
</code></pre>
</div>

<p>这行代码创建了几个对象？答案是两个，首先在字符创常量池中创建 <code class="highlighter-rouge">"test"</code>,由于使用了 <code class="highlighter-rouge">new</code> 操作符，再在堆中创建新的 <code class="highlighter-rouge">String</code> 对象。</p>

<p>如果你理解了前面的内容，下面语句的结果就显而易见了：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// false</span>
</code></pre>
</div>

<p>这里引申一句题外话，Java 中的 <code class="highlighter-rouge">==</code> 操作符比较的是变量引用的地址，因此对于对象不能直接使用 <code class="highlighter-rouge">==</code> 进行比较。如果只是比较 String 的字面值，可以使用其自带的 <code class="highlighter-rouge">equals()</code> 函数：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>另外，Java 更推荐直接使用字符串常量池创建字符串，而不是通过 <code class="highlighter-rouge">new</code> 操作符。</p>

<p>最后，我们来探讨一下编译器的有趣之处，看下面的例子：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"aaabbb"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"aaa"</span> <span class="o">+</span> <span class="s">"bbb"</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>   <span class="c1">// true</span>
</code></pre>
</div>

<p>编译器似乎十分“聪明”，在编译期对我们的语句进行了一些优化。不过，编译器也没有那么“聪明”：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"aaa"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"bbb"</span><span class="o">;</span>

<span class="n">String</span> <span class="n">m</span> <span class="o">=</span> <span class="s">"aaabbb"</span><span class="o">;</span>
<span class="n">String</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="o">);</span>   <span class="c1">// false</span>
</code></pre>
</div>

<p>如果在 <code class="highlighter-rouge">+</code> 操作符的两边存在非常量，即使连接后的字符串存在于常量池中，依旧会创建新的对象。</p>

	
</div>

		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/none"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/none"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
