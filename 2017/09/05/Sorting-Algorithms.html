<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Sorting Algorithms</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">Sorting Algorithms</div>
	<span class="post-date">
		<time>05 Sep 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#algorithm">
					<span>algorithm</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="overview">Overview</h2>
<p>When processing data, sorting algorithms are always used. Although most languages have related libraries that can be easily invoked, understanding the principles of such algorithms can help us make better use of them.</p>

<p>If there’s no special statement, we sort data in ascending order in this blog, and the data set is:</p>

<blockquote>
  <p>5 8 1 5 2 4 7 9 8</p>
</blockquote>

<h2 id="bubble-sort">Bubble Sort</h2>
<p>This is usually the first sorting algorithm for a new comer to algorithms:</p>

<ol>
  <li>In each round, keep comparing every two neighbouring elements, and if the first one is greater, <code class="highlighter-rouge">swap</code> the two elements.</li>
  <li>After one round, the last element in the array is the greatest one among the unsorted sequence.</li>
  <li>Narrow down the unsorted sequence to exclude the last element (because it is at the right location).</li>
  <li>Repeat process #1 to #3, until there’s only one element in the unsorted sequence.</li>
</ol>

<p>If you understand the principle of this algorithm, you’ll know why it is called <code class="highlighter-rouge">Bubble Sort</code>: after every round, the bigger elements <code class="highlighter-rouge">sink down</code> to the end of the array, and smaller ones <code class="highlighter-rouge">bubble up</code> to the front, until all elements are at their right positions. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The reason why it is regarded as a entry-level algorithm is that it is very simple, and at the same time, this algorithm is not efficient at all. Obviously, due to the <code class="highlighter-rouge">double loop</code>, the average time complexity of Bubble Sort is <code class="highlighter-rouge">O(n ^ 2)</code>. When the data grows larger, the speed of this algorithm is unacceptable. However, on the other hand, this algorithm has two advantages: it can be finished in the original array, so the space complexity is <code class="highlighter-rouge">O(1)</code>, and it is a <code class="highlighter-rouge">stable</code> algorithm, which means:</p>

<blockquote>
  <p>The order of the equal elements in the original array remains the same after the sort.</p>
</blockquote>

<h2 id="select-sort">Select Sort</h2>
<p>Also a entry-level sorting algorithm. The thinking is simple: each round find the smallest element in the unsorted sequence, and swap it with the first element in the sequence, and narrow down the sequence until only one element remains. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">selectSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">currMinIndex</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">currMinIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">currMinIndex</span><span class="o">])</span> <span class="n">currMinIndex</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">currMinIndex</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">currMinIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Similar to the Bubble Sort, the time complexity of <code class="highlighter-rouge">Select Sort</code> is <code class="highlighter-rouge">O(n ^ 2)</code>, and the spacve complexity is <code class="highlighter-rouge">O(1)</code>, but it is <code class="highlighter-rouge">unstable</code>, because each swap will possibly change the order of the equal elements.</p>

<h2 id="insert-sort">Insert Sort</h2>
<p>As the name suggests, we maintain a sorted sequence, and insert every element from the unsorted sequence to its right position in the sorted sequence. We can do this in-place: when handling the element indexed <code class="highlighter-rouge">i</code>, the first <code class="highlighter-rouge">i - 1</code> elements are sorted, so after inserting the <code class="highlighter-rouge">i</code>th element, move each element behind it by one place. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">insertSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="k">break</span><span class="o">;</span>

            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The time complexity of <code class="highlighter-rouge">Insert Sort</code> is still <code class="highlighter-rouge">O(n ^ 2)</code>, and the space complexity also remains <code class="highlighter-rouge">O(1)</code>.</p>

<h2 id="bucket-sort">Bucket Sort</h2>
<p>This algorithm is somewhat magical, because its time complexity is <code class="highlighter-rouge">O(n)</code>! Let’s see the implementation first:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">bucketSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">arr</span><span class="o">)</span>
        <span class="n">bucket</span><span class="o">[</span><span class="n">num</span><span class="o">]++;</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">j</span><span class="o">++)</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

    <span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In fact, it’s fairly simple. It just calculates the frequency of every element in the original array with an extra array, and traverse the auxiliary to get the sorting result.</p>

<p>You may realize that though this algorithm has a low time complexity, its space complexity is high, which is <code class="highlighter-rouge">O(K)</code>. <code class="highlighter-rouge">K</code> is greatest element in the original array. Therefore, this is a typical <code class="highlighter-rouge">space-for-time</code> algorithm. If the distribution of data is even, it can be very efficient; but for messy data, the space consumption of this algorithm is horrible. In brief, <code class="highlighter-rouge">Bucket Sort</code> can only be applied to some certain occations.</p>

<h2 id="quick-sort">Quick Sort</h2>
<p>If <code class="highlighter-rouge">Bubble Sort</code>, <code class="highlighter-rouge">Select Sort</code> and <code class="highlighter-rouge">Insert Sort</code> belong to the same level, we are getting to another level, starting with <code class="highlighter-rouge">Quick Sort</code>.</p>

<p>The key point of Quick Sort is <code class="highlighter-rouge">"Divide and Conquer"</code>, that is, divide big problem into small ones, and when all small problems are handled, the big one is therefore handled. Let’s see the description of the algorithm:</p>

<ol>
  <li>Select one element from the array as <code class="highlighter-rouge">base element</code></li>
  <li>Put all elements that are smaller than the base element to its left, and all bigger ones on the right</li>
  <li>Repeat process #1 to #3 until there is only one element in the interval</li>
</ol>

<p>Generally, we choose the first element of the interval as the base element. Here’s an example:</p>

<ol>
  <li>
    <p>The original array:
<img src="/assets/images/0913/1-0.png" alt="" /></p>
  </li>
  <li>
    <p>Select the first element as base element. Maintain two pointers <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">j</code>, pointing to the head and tail of the array respectively.
<img src="/assets/images/0913/1-1.png" alt="" /></p>
  </li>
  <li>
    <p>Move <code class="highlighter-rouge">j</code> to the left, to find the <code class="highlighter-rouge">first</code> element that is <code class="highlighter-rouge">smaller</code> than the base element. Extract it and fill it to the location that <code class="highlighter-rouge">i</code> points to
<img src="/assets/images/0913/1-2.png" alt="" /></p>
  </li>
  <li>
    <p>Move <code class="highlighter-rouge">i</code> to the right, to find the <code class="highlighter-rouge">first</code> element that is <code class="highlighter-rouge">bigger</code> than the base element. Extract it and fill it to the location that <code class="highlighter-rouge">j</code> points to
<img src="/assets/images/0913/1-3.png" alt="" /></p>
  </li>
  <li>
    <p>Repeat process #3 to #4, until <code class="highlighter-rouge">i</code> meets <code class="highlighter-rouge">j</code>
<img src="/assets/images/0913/1-4.png" alt="" /></p>
  </li>
  <li>
    <p>Fill the base element to the position that <code class="highlighter-rouge">i</code> (or <code class="highlighter-rouge">j</code>) points to
<img src="/assets/images/0913/1-6.png" alt="" /></p>
  </li>
</ol>

<p>!Attention: in process #3, it must start from the <code class="highlighter-rouge">rightmost</code>.</p>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">base</span><span class="o">)</span> <span class="n">j</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">base</span><span class="o">)</span> <span class="n">i</span><span class="o">++;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">--]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>

    <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As for a array of length <code class="highlighter-rouge">n</code>, suppost every time the base element selected by the Quick Sort divides the array to two parts of equal lengh, then:</p>

<p><img src="/assets/images/0913/1-l.png" alt="" /></p>

<p>All <code class="highlighter-rouge">logn</code> rounds is needed, and each round the whole array will be accessed, so the average time complexity is <code class="highlighter-rouge">O(nlogn)</code>. Since the sorting is done in-place, and no extra space is used, the spae complexity is <code class="highlighter-rouge">O(1)</code>. In addition, obviously, due to the swap, Quick Sort is <code class="highlighter-rouge">unstable</code>.</p>

<h2 id="merge-sort">Merge Sort</h2>
<p>First, if we have two sorted array, how to merge them into one sorted array? I velieve many people know the answer: keep comparing the first elements of the two array, and each time extract the smaller one to the result array, until one of the array is empty. Finally append the array that is not empty to the end of the result array:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">arr1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="o">}</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
        <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
        <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Based on this code, with <code class="highlighter-rouge">"Divide and Conquer"</code>, we can realize the <code class="highlighter-rouge">Merge Sort</code>:</p>

<ol>
  <li>Divide the array to two parts, and do Merge Sort on them respectively</li>
  <li>Merge the two sorted result array</li>
  <li>Repeat process #1 to #3, until there’s only one element in the interval</li>
</ol>

<p>Improve the previous code a little bit, and we have the implementation:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
    
    <span class="n">mergeSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
    <span class="n">mergeSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

    <span class="n">merge</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="o">}</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">)</span>
        <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">)</span>
        <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">s</span> <span class="o">+</span> <span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Similar to the Quick Sort, the time complexity of Merge Sort is <code class="highlighter-rouge">O(nlongn)</code>, but in the process of merging, we need at most an auxiliary array with the same lengh as the original array, so the space complexity is <code class="highlighter-rouge">O(n)</code>. Besides, if every time we meet the situation that the head elements of the two array are equal, we guarantee the element from the first array is selected, Merge Sort can be <code class="highlighter-rouge">stable</code>.</p>

<h2 id="heap-sort">Heap Sort</h2>
<p><code class="highlighter-rouge">Heap Sort</code> uses a special data structure – <code class="highlighter-rouge">heap</code>, and its implementation is somewhat more complicate than the previous algorithms. We will begin with <code class="highlighter-rouge">Heap</code> and then come to the actual algorithm.</p>

<h3 id="heap">Heap</h3>
<p>Since we are sorting in ascending order, I will introduce the <code class="highlighter-rouge">Minimum Heap</code>:</p>

<ol>
  <li>A minimum heap is a <code class="highlighter-rouge">complete binary tree</code></li>
  <li>The parent node is always smaller than (or equal to) its children</li>
  <li>Children are also minimum heap</li>
</ol>

<h3 id="storing-in-an-array">Storing in an Array</h3>
<p>As we mentioned above, heap is a <code class="highlighter-rouge">complete binary tree</code>, so we can use some tricks to store it in an array, and easily access nodes by index. For example, if we have the following heap:</p>

<p><img src="/assets/images/0913/2-0.png" alt="" /></p>

<p>Put every node into an array according to its level-traversing order:</p>

<p><img src="/assets/images/0913/2-1.png" alt="" /></p>

<p>You will find that, for every node indexed <code class="highlighter-rouge">i</code>, the index of its left child is <code class="highlighter-rouge">2 * i + 1</code>, the index of the right child is <code class="highlighter-rouge">2 * i + 2</code>, and the index of its parent is <code class="highlighter-rouge">(i - 1) / 2</code>.</p>

<h3 id="insertion">Insertion</h3>
<p>As for the heap above, if we want to insert <code class="highlighter-rouge">2</code> into it:</p>

<ol>
  <li>
    <p>Put the new element to the end of the array
<img src="/assets/images/0913/2-2.png" alt="" /></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">"Adjust upward"</code>, that is, compare it with the parent node. If it is smaller than its parent, swap them
<img src="/assets/images/0913/2-3.png" alt="" /></p>
  </li>
  <li>
    <p>Repeat process #2, until current node is bigger than the parent node, or it reaches the root.
<img src="/assets/images/0913/2-4.png" alt="" /></p>
  </li>
</ol>

<p>The code for <code class="highlighter-rouge">"adjust upward"</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">fixUp</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">currVal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">parentIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">parentIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">parentIndex</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">currVal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">parentIndex</span><span class="o">];</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">parentIndex</span><span class="o">;</span>
        <span class="n">parentIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">currVal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="deletion">Deletion</h3>
<p>Becuase of the characteristic of the heap, deletion can only be done to the top element. After deletion, we move the last element of the heap to the top, and <code class="highlighter-rouge">"adjust downward"</code>. Again the previous example:</p>

<ol>
  <li>
    <p>Extract the top element <code class="highlighter-rouge">1</code>, and move the last element <code class="highlighter-rouge">8</code> to the top
<img src="/assets/images/0913/2-5.png" alt="" /></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">"Adjust downward"</code>, that is, compare it with all children. If either children is smaller than it, swap them
<img src="/assets/images/0913/2-6.png" alt="" /></p>
  </li>
  <li>
    <p>Repeat process #2, until no child is smaller than current node, or it reaches the leaf
<img src="/assets/images/0913/2-7.png" alt="" /></p>
  </li>
</ol>

<p>The code for <code class="highlighter-rouge">"adjust downward"</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">fixDown</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">currVal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">minChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">minChildIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">minChildIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span><span class="o">])</span> <span class="n">minChildIndex</span><span class="o">++;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">currVal</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

        <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span><span class="o">];</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">minChildIndex</span><span class="o">;</span>
        <span class="n">minChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">currVal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="initialization">Initialization</h3>
<p>For a given array, say our example, <code class="highlighter-rouge">5 8 1 5 2 4 7 9 8</code>, the processes to transform it to a heap is as follows:</p>

<ol>
  <li>
    <p>The initial data
<img src="/assets/images/0913/2-8.png" alt="" /></p>
  </li>
  <li>
    <p>Start from <code class="highlighter-rouge">the last node that is not leaf</code>, adjust downward. Since the last two not-leaf node are currently minimum heaps, they are not to be adjusted
<img src="/assets/images/0913/2-9.png" alt="" /></p>
  </li>
  <li>
    <p>Adjust the subtree rooted by the last but two node, and it triggers one swap
<img src="/assets/images/0913/2-10.png" alt="" /></p>
  </li>
  <li>
    <p>Adjust the subtree rooted by the root (the whole tree), and it triggers two swaps
<img src="/assets/images/0913/2-11.png" alt="" /></p>
  </li>
</ol>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">fixDown</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="heap-sort-1">Heap Sort</h3>
<p>After introducing all above, we can finally sort with Heap Sort. Simply, we just <code class="highlighter-rouge">heapify</code> (initialize) the array, and keep extracting the top element and move the last element to the top, and then <code class="highlighter-rouge">adjust downward</code> form the top. The code is as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">init</span><span class="o">(</span><span class="n">len</span><span class="o">);</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
        <span class="n">fixDown</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="analysis">Analysis</h3>
<p>Heap Sort utilizes <code class="highlighter-rouge">complete binary tree</code>, so no matter what type of data we have, the time complexity of Heap Sort is <code class="highlighter-rouge">O(nlongn)</code>, and the space complexity is <code class="highlighter-rouge">O(1)</code>. Besides, due to the swap, Heap sort is <code class="highlighter-rouge">unstable</code>.</p>

<h2 id="summary">Summary</h2>
<p>There are many sorting algorithms. Although few people implement them personally, have a understanding of their principles is always benefical.</p>

<hr />

<h2 id="总览">总览</h2>
<p>在处理数据时，排序算法经常被使用。虽然大部分语言都有相关库方便我们调用，了解这些算法的具体实现机制有助于加深我们对算法的理解，以及更好的使用这些算法。</p>

<p>如无特殊声明，本文的排序算法输出均为 <code class="highlighter-rouge">升序</code>，使用的数据为：</p>

<blockquote>
  <p>5 8 1 5 2 4 7 9 8</p>
</blockquote>

<h2 id="冒泡排序">冒泡排序</h2>
<p>这大概是学习算法的人接触到的第一个排序算法：</p>

<ol>
  <li>在每一轮，不断比较每相邻的两个元素，如果第一个元素比第二个大，交换二者位置。</li>
  <li>完成一轮后，数组最后的元素是待排序序列中最大的元素。</li>
  <li>缩小待比较序列，不再包括上一个序列中最后的元素（已处在合适位置）。</li>
  <li>重复上述步骤直到待排序序列只剩下一个元素。</li>
</ol>

<p>如果理解了这个算法，就能明白它为什么被称作 <code class="highlighter-rouge">冒泡排序</code>，因为每一轮较大的元素 <code class="highlighter-rouge">沉底</code>，小元素 <code class="highlighter-rouge">上浮到</code> 靠前的位置，直到所有元素都处在合适的位置。实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
				<span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
				<span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>之所以被称作入门级算法，就是因为它的实现非常简单，但同时，这个算法的效率确是十分低的。很明显，由于使用双重循环，冒泡排序的平均时间复杂度为 <code class="highlighter-rouge">O(n ^ 2)</code>，在数组较大的情况下速度是无法接受的。不过另一方面，冒泡排序也有一个优点是它可以在原数组内完成，不需要额外的存储空间，空间复杂度为 <code class="highlighter-rouge">O(1)</code>。另外，冒泡排序是 <code class="highlighter-rouge">稳定的</code> 排序算法，即</p>

<blockquote>
  <p>原数组中相等元素的先后顺序在排序后的数组里得以维持。</p>
</blockquote>

<h2 id="选择排序">选择排序</h2>
<p>也算是一个入门级的排序算法。思路十分简单，每一轮找出待排序序列中最小的元素，并将其与该序列中第一个元素交换，直至待排序序列只剩下一个元素。实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">selectSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">currMinIndex</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="n">currMinIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">currMinIndex</span><span class="o">])</span> <span class="n">currMinIndex</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
		<span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">currMinIndex</span><span class="o">];</span>
		<span class="n">arr</span><span class="o">[</span><span class="n">currMinIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>与冒泡排序类似，选择排序的时间复杂度为 <code class="highlighter-rouge">O(n ^ 2)</code>，空间复杂度为 <code class="highlighter-rouge">O(1)</code>，但是选择排序是 <code class="highlighter-rouge">不稳定的</code>，因为每次交换的时候会导致相同元素在数组中的次序变化。</p>

<h2 id="插入排序">插入排序</h2>
<p>顾名思义，维护一个已排序好的序列，依次将数组中的元素插入到该序列中的合适位置。我们可以直接在原数组中操作，在处理下标为 <code class="highlighter-rouge">i</code> 的元素时，数组中的前 <code class="highlighter-rouge">i - 1</code> 个元素已排序好，将下标 <code class="highlighter-rouge">i</code> 的元素放置到合适位置后，依次后移其之后的元素，以实现插入。实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">insertSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="k">break</span><span class="o">;</span>

			<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
			<span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
			<span class="n">arr</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个算法的时间复杂度是 <code class="highlighter-rouge">O(n ^ 2)</code>，空间复杂度为 <code class="highlighter-rouge">O(1)</code>，并且是 <code class="highlighter-rouge">稳定的</code>。</p>

<h2 id="桶排序">桶排序</h2>
<p>这里要介绍一个有些神奇的算法，因为它的时间复杂度可以达到惊人的 <code class="highlighter-rouge">O(n)</code>！我们先来看它的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">bucketSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">bucket</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span> <span class="n">arr</span><span class="o">)</span>
		<span class="n">bucket</span><span class="o">[</span><span class="n">num</span><span class="o">]++;</span>

	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">j</span><span class="o">++)</span>
			<span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

	<span class="k">return</span> <span class="n">arr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实际上，这个算法很简单，使用额外的数组统计原数组中每个元素出现的次数，然后遍历这个统计数组得到排序结果。</p>

<p>你应该已经发现了，虽然这个算法时间复杂度很低，但是空间复杂度为 <code class="highlighter-rouge">O(K)</code>，其中，<code class="highlighter-rouge">K</code> 为数组中值最大的元素。因此，这是一个典型的 <code class="highlighter-rouge">空间换时间</code> 的算法。对于分布较为集中的数据，使用这个算法有奇效；但是对于跨度比较大的数据，其空间消耗是我们不能接受的。总之，这个算法适用于一些特定的场合。</p>

<h2 id="快速排序">快速排序</h2>
<p>如果 <code class="highlighter-rouge">冒泡排序</code>，<code class="highlighter-rouge">选择排序</code>，<code class="highlighter-rouge">插入排序</code> 为一个档次的算法，那么从快速排序开始，我们进入了另一个档次。</p>

<p>快速排序的关键在于 <code class="highlighter-rouge">分治 + 递归</code>， 即将大问题化为小问题来解决，这样当所有小问题都解决之后，大问题也就解决了。我们先来看算法描述：</p>

<ol>
  <li>从数组中选出一个数作为 <code class="highlighter-rouge">基准数</code></li>
  <li>将所有比基准数小的数放在它的左边，比它大的数放在右边</li>
  <li>对每一边重复应用步骤1-3，直到该区间只有一个数。</li>
</ol>

<p>一般来说，选取该区间的第一个数作为基准数，我们来看一个例子：</p>

<ol>
  <li>
    <p>原数组
<img src="/assets/images/0913/1-0.png" alt="" /></p>
  </li>
  <li>
    <p>取出第一个数作为基准数，维护两个指针 <code class="highlighter-rouge">i</code> 和 <code class="highlighter-rouge">j</code> 分别指向数组的头和尾
<img src="/assets/images/0913/1-1.png" alt="" /></p>
  </li>
  <li>
    <p>向左移动 <code class="highlighter-rouge">j</code>，找到 <code class="highlighter-rouge">第一个</code> 比基准数 <code class="highlighter-rouge">小</code> 的数，取出填到 <code class="highlighter-rouge">i</code> 所在的位置
<img src="/assets/images/0913/1-2.png" alt="" /></p>
  </li>
  <li>
    <p>向右移动 <code class="highlighter-rouge">i</code>，找到 <code class="highlighter-rouge">第一个</code> 比基准数 <code class="highlighter-rouge">大</code> 的数，取出填到 <code class="highlighter-rouge">j</code> 所在的位置
<img src="/assets/images/0913/1-3.png" alt="" /></p>
  </li>
  <li>
    <p>重复步骤3、4，直到 <code class="highlighter-rouge">i</code> 与 <code class="highlighter-rouge">j</code> 相遇
<img src="/assets/images/0913/1-4.png" alt="" /></p>
  </li>
  <li>
    <p>将基准数填入 <code class="highlighter-rouge">i</code> （或 <code class="highlighter-rouge">j</code>）所在位置
<img src="/assets/images/0913/1-5.png" alt="" /></p>
  </li>
  <li>
    <p>分别对左区间 <code class="highlighter-rouge">[start, i - 1]</code>，及右区间 <code class="highlighter-rouge">[i + 1, end]</code> 执行步骤1-7，直到区间内只有一个数
<img src="/assets/images/0913/1-6.png" alt="" /></p>
  </li>
</ol>

<p>*注意： <code class="highlighter-rouge">第3步</code> 中，一定要先从 <code class="highlighter-rouge">最右边</code> 开始向左找。</p>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">base</span><span class="o">)</span> <span class="n">j</span><span class="o">--;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

		<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">base</span><span class="o">)</span> <span class="n">i</span><span class="o">++;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">--]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
	<span class="o">}</span>

	<span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>

	<span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
	<span class="n">quickSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对于长度为 <code class="highlighter-rouge">n</code> 的数组，假设快速排序每次选取的基准数将数组分为长度相等的两部分，那么：</p>

<p><img src="/assets/images/0913/1-l.png" alt="" /></p>

<p>一共需要进行 <code class="highlighter-rouge">o(logn)</code> 轮，每轮访问一遍整个数组，所以平均时间复杂度为 <code class="highlighter-rouge">O(nlogn)</code>。由于在数组内排序，没有使用额外空间，空间复杂度为 <code class="highlighter-rouge">O(1)</code>。另外，很明显，由于交换操作，快速排序是 <code class="highlighter-rouge">不稳定的</code>。</p>

<h2 id="归并排序">归并排序</h2>
<p>首先，对于两个有序的数组，如何将他们和合并成一个有序数组？我相信这个问题很多人都知道如何解决，只需不断比较两个数组的第一个元素，将较小的取出依次放到结果数组中，直至其中一个数组为空，最后将不为空的数组的剩余元素逐个添加到结果数组中。代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">arr1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
		<span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
	<span class="o">}</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
		<span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
		<span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr2</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在这个代码的基础上，利用 <code class="highlighter-rouge">分治 + 递归</code>，我们就可以实现 <code class="highlighter-rouge">归并排序</code>：</p>

<ol>
  <li>将数组分为两半，分别进行归并排序</li>
  <li>将得到的两个有序数组合并</li>
  <li>重复步骤1-3，直至区间中只有一个数</li>
</ol>

<p>对先前的合并算法稍加改进，实现如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

	<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
	
	<span class="n">mergeSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
	<span class="n">mergeSort</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

	<span class="n">merge</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
		<span class="k">else</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
	<span class="o">}</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">)</span>
		<span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">)</span>
		<span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>

	<span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
		<span class="n">arr</span><span class="o">[</span><span class="n">s</span> <span class="o">+</span> <span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<p>与快速排序类似，归并排序的时间复杂度为 <code class="highlighter-rouge">O(nlogn)</code>，但是在合并的过程中，最大需要使用到与原数组等长的辅助数组，所以其空间复杂度为 <code class="highlighter-rouge">O(n)</code>。另外，如果我们在归并的过程中，遇到两个序列的头元素相等的情况时，先将前一个序列的元素放到结果数组中，就可以保证其是 <code class="highlighter-rouge">稳定的</code>。</p>

<h2 id="堆排序">堆排序</h2>
<p><code class="highlighter-rouge">堆排序</code> 使用到了特殊的数据结构——<code class="highlighter-rouge">堆</code>，实现较前面的算法稍为复杂，因此这一部分将先从 <code class="highlighter-rouge">堆</code> 讲起，最后在讨论排序算法。</p>

<h3 id="堆">堆</h3>
<p>由于本文始终以升序排序为例，这里介绍一下 <code class="highlighter-rouge">最小二叉堆</code>：</p>

<blockquote>
  <ol>
    <li>最小二叉堆是一个完全二叉树</li>
    <li>父节点的值总是小于等于子节点的值</li>
    <li>子树也是最小二叉堆。</li>
  </ol>
</blockquote>

<h3 id="使用数组存储">使用数组存储</h3>
<p>前面提到了，堆是 <code class="highlighter-rouge">完全二叉树</code>，因此可以使用一些技巧将其存储在数组中，并轻松通过下标访问子节点。如，对于如下二叉堆：</p>

<p><img src="/assets/images/0913/2-0.png" alt="" /></p>

<p>按照层次遍历的顺序放到数组中：</p>

<p><img src="/assets/images/0913/2-1.png" alt="" /></p>

<p>可以发现，对于在数组中序号为 <code class="highlighter-rouge">i</code> 的节点，其左子树的序号为 <code class="highlighter-rouge">2 * i + 1</code>，右子树的序号的 <code class="highlighter-rouge">2 * i + 2</code>，父节点序号为 <code class="highlighter-rouge">(i - 1) / 2</code>。</p>

<h3 id="插入">插入</h3>
<p>假设对于上图的堆，如果要想其中插入数据，比如 <code class="highlighter-rouge">2</code>。</p>

<ol>
  <li>
    <p>先将新元素放到数组的最后
<img src="/assets/images/0913/2-2.png" alt="" /></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">向上调整</code>，即与父节点比较，如果小于父节点则与父节点交换
<img src="/assets/images/0913/2-3.png" alt="" /></p>
  </li>
  <li>
    <p>重复步骤2，直至当前节点的值小于父节点的值，或已调整到根节点
<img src="/assets/images/0913/2-4.png" alt="" /></p>
  </li>
</ol>

<p><code class="highlighter-rouge">向上调整</code> 实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">fixUp</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">currVal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
	<span class="kt">int</span> <span class="n">parentIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">parentIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">parentIndex</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">currVal</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">parentIndex</span><span class="o">];</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">parentIndex</span><span class="o">;</span>
		<span class="n">parentIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">currVal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>
<p>由于堆的性质，只能删除堆顶元素，然后将堆的最后一个元素放到堆顶，再向下调整。比如对于之前的例子：</p>

<ol>
  <li>
    <p>取出堆顶元素 <code class="highlighter-rouge">1</code>，将最后一个元素 <code class="highlighter-rouge">8</code> 放到堆顶
<img src="/assets/images/0913/2-5.png" alt="" /></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">向下调整</code>，即与子节点比较，如果有子节点小于它则与最小的子节点交换
<img src="/assets/images/0913/2-6.png" alt="" /></p>
  </li>
  <li>
    <p>重复步骤2，直至没有子节点的值比当前节点的值小，或已到达叶子节点
<img src="/assets/images/0913/2-7.png" alt="" /></p>
  </li>
</ol>

<p><code class="highlighter-rouge">向下调整</code> 实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">fixDown</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">currVal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
	<span class="kt">int</span> <span class="n">minChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">minChildIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">minChildIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span><span class="o">])</span> <span class="n">minChildIndex</span><span class="o">++;</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">currVal</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

		<span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">minChildIndex</span><span class="o">];</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">minChildIndex</span><span class="o">;</span>
		<span class="n">minChildIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">currVal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="初始化堆">初始化堆</h3>
<p>对于一个给定的数组，如我们的例子：<code class="highlighter-rouge">5 8 1 5 2 4 7 9 8</code>，将其变成一个堆的过程如下：</p>

<ol>
  <li>
    <p>原始数据
<img src="/assets/images/0913/2-8.png" alt="" /></p>
  </li>
  <li>
    <p>从 <code class="highlighter-rouge">最后一个非叶子节点</code> 开始，向下调整。以最后两个非叶子节点为根的树都已满足最小堆，无需调整
<img src="/assets/images/0913/2-9.png" alt="" /></p>
  </li>
  <li>
    <p>调整以倒数第三个节点为根的子树，触发一次交换
<img src="/assets/images/0913/2-10.png" alt="" /></p>
  </li>
  <li>
    <p>调整以根节点为根的子树，触发两次交换
<img src="/assets/images/0913/2-11.png" alt="" /></p>
  </li>
</ol>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="n">fixDown</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="堆排序-1">堆排序</h3>
<p>介绍了前面这些，我们终于可以运用堆进行排序了。很简单，只需要将输入数据先 <code class="highlighter-rouge">堆化</code>，再不断取出堆顶元素，将堆中最后一个元素放到堆顶，从堆顶开始执行 <code class="highlighter-rouge">向下调整</code> 即可。实现代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">init</span><span class="o">(</span><span class="n">len</span><span class="o">);</span>

	<span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
		<span class="n">res</span><span class="o">[</span><span class="n">c</span><span class="o">++]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

		<span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
		<span class="n">fixDown</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="分析">分析</h3>
<p>堆排序使用 <code class="highlighter-rouge">完全二叉树</code> 构建，所以无论是怎样的数据，堆排序的时间复杂度都为 <code class="highlighter-rouge">O(nlogn)</code>，空间复杂度为 <code class="highlighter-rouge">O(1)</code>。另外，由于交换，堆排序是 <code class="highlighter-rouge">不稳定的</code>。</p>

<h2 id="总结">总结</h2>
<p>排序算法有很多，虽然平时很少有人自己实现排序算法，了解一下常见的排序算法的实现原理总是有好处的。</p>

	
</div>

		
		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/dontsay_lazy"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/hao-cui-3ab90214b"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
