<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>翻转单链表的5种方法</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">翻转单链表的5种方法</div>
	<span class="post-date">
		<time>05 Sep 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#algorithm">
					<span>algorithm</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="总览">总览</h2>
<p>常见的对单链表进行翻转有5种方法，下面将分别介绍。其中，类 <code class="highlighter-rouge">Node</code> 的定义如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

	<span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
	
	<span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre>
</div>

<h2 id="使用数组存储">使用数组存储</h2>
<p>遍历单链表，并将其存储在可 <code class="highlighter-rouge">随机访问</code> 的数据结构（如数组）中，随后反向遍历该数据结构，构建新的链表。由于最简单，不多做介绍，直接给出代码：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList1</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">arr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p>很明显，这个代码最大的问题就是空间代价太大，需要建立一个与链表等长的数据结构。</p>

<h2 id="不断翻转每两个节点之间的指向">不断翻转每两个节点之间的指向</h2>
<p>如果把相邻两个节点的指向逐一翻转，最终将实现对整个链表的翻转，描述如下：</p>

<ul>
  <li>定义 <code class="highlighter-rouge">currHead</code>，<code class="highlighter-rouge">next</code> 两个变量，分别指向当前链表的头以及头的下一个节点；额外定义变量 <code class="highlighter-rouge">temp</code> 用于临时储存节点。</li>
  <li>首先将 <code class="highlighter-rouge">currHead</code> （省略“指向的”，下同）节点的下一个节点指向 <code class="highlighter-rouge">null</code>。</li>
  <li>进入循环。</li>
  <li>将 <code class="highlighter-rouge">temp</code> 指向 <code class="highlighter-rouge">next</code> 节点的下一个节点。</li>
  <li>将 <code class="highlighter-rouge">next</code> 节点的下一个节点指向 <code class="highlighter-rouge">currHead</code> 节点。</li>
  <li>将 <code class="highlighter-rouge">currHead</code> 指向 <code class="highlighter-rouge">next</code> 节点；将 <code class="highlighter-rouge">next</code> 指向 <code class="highlighter-rouge">temp</code> 节点。</li>
  <li>循环直至 <code class="highlighter-rouge">next</code> 节点 为 <code class="highlighter-rouge">null</code>。</li>
  <li><code class="highlighter-rouge">currHead</code> 节点即为翻转后链表的头。</li>
</ul>

<p>用具体的例子可能更方便理解。假设有链表 <code class="highlighter-rouge">1 -&gt; 2-&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，翻转过程如下：</p>

<ol>
  <li>
    <p>初始链表
<img src="/assets/images/0905/2-0.png" alt="" /></p>
  </li>
  <li>
    <p>初始化
<img src="/assets/images/0905/2-1.png" alt="" /></p>
  </li>
  <li>
    <p>进入循环
<img src="/assets/images/0905/2-2.png" alt="" /></p>
  </li>
  <li>
    <p>翻转前两个节点的指向
<img src="/assets/images/0905/2-3.png" alt="" /></p>
  </li>
  <li>
    <p>向前移动
<img src="/assets/images/0905/2-4.png" alt="" /></p>
  </li>
  <li>
    <p>开始第二次循环
<img src="/assets/images/0905/2-5.png" alt="" /></p>
  </li>
  <li>
    <p>继续循环直至 <code class="highlighter-rouge">next</code> 指向 <code class="highlighter-rouge">null</code>，此时 <code class="highlighter-rouge">currHead</code> 指向翻转后的节点头
<img src="/assets/images/0905/2-6.png" alt="" /></p>
  </li>
</ol>

<p>代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList2</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">currHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

	<span class="n">currHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

		<span class="n">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">currHead</span><span class="o">;</span>

		<span class="n">currHead</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">currHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="不断将原链表的节点放到新链表的头部">不断将原链表的节点放到新链表的头部</h2>
<p>这种方法思路和实现都不难，只需将原链表的节点逐一添加到新链表的头部即可。还是 <code class="highlighter-rouge">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code> 的例子，翻转过程的描述和示例一起展示如下：</p>

<ol>
  <li>
    <p>初始化：<code class="highlighter-rouge">newHead</code> 指向 <code class="highlighter-rouge">null</code>，<code class="highlighter-rouge">head</code> 指向原链表的头
<img src="/assets/images/0905/3-0.png" alt="" /></p>
  </li>
  <li>
    <p>进入循环：将 <code class="highlighter-rouge">temp</code> 指向 <code class="highlighter-rouge">head</code> 节点的下一个节点；将 <code class="highlighter-rouge">head</code> 节点的下一个节点指向 <code class="highlighter-rouge">newHead</code> 节点
<img src="/assets/images/0905/3-1.png" alt="" /></p>
  </li>
  <li>
    <p>向前移动：将 <code class="highlighter-rouge">newHead</code> 指向 <code class="highlighter-rouge">head</code> 节点；将 <code class="highlighter-rouge">head</code> 指向 <code class="highlighter-rouge">temp</code> 节点
<img src="/assets/images/0905/3-2.png" alt="" /></p>
  </li>
  <li>
    <p>进入下一次循环
<img src="/assets/images/0905/3-3.png" alt="" /></p>
  </li>
  <li>
    <p>循环直至 <code class="highlighter-rouge">head</code> 指向 <code class="highlighter-rouge">null</code>，此时 <code class="highlighter-rouge">newHead</code> 指向翻转后的链表头
<img src="/assets/images/0905/3-4.png" alt="" /></p>
  </li>
</ol>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList3</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="n">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

		<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">;</span>

		<span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">newHead</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="不断将原链表头的下一个节点插入新链表头之后">不断将原链表头的下一个节点插入新链表头之后</h2>
<p>使用这个方法需要构造一个辅助节点，链接到原链表头之前，随后不断将原链表头的 <code class="highlighter-rouge">下一个节点</code> 插入到辅助节点之后，直至原链表头的下一个节点为 <code class="highlighter-rouge">null</code>，此时辅助节点的下一个节点即为翻转后链表的头。算法描述及示例如下：</p>

<ol>
  <li>
    <p>初始化：构造辅助节点 <code class="highlighter-rouge">newHead</code>，链接到原链表头
<img src="/assets/images/0905/4-0.png" alt="" /></p>
  </li>
  <li>
    <p>进入循环：将 <code class="highlighter-rouge">temp</code> 指向 <code class="highlighter-rouge">head</code> 节点的下一个节点
<img src="/assets/images/0905/4-1.png" alt="" /></p>
  </li>
  <li>
    <p>插入：将 <code class="highlighter-rouge">head</code> 节点的下一个节点指向 <code class="highlighter-rouge">temp</code> 的下一个节点；将 <code class="highlighter-rouge">temp</code> 节点的下一个节点指向 <code class="highlighter-rouge">newHead</code> 节点的下一个节点；将 <code class="highlighter-rouge">newHead</code> 节点的下一个节点指向 <code class="highlighter-rouge">temp</code> 节点。这样就将 <code class="highlighter-rouge">head</code> 节点的下一个节点插入到新链表头之后
<img src="/assets/images/0905/4-2.png" alt="" /></p>
  </li>
  <li>
    <p>进入下一轮循环，操作同步骤2、3
<img src="/assets/images/0905/4-3.png" alt="" /></p>
  </li>
  <li>
    <p>循环直至 <code class="highlighter-rouge">head</code> 节点的下一个节点为 <code class="highlighter-rouge">null</code>，此时 <code class="highlighter-rouge">newHead</code> 节点的下一个节点为翻转后链表的头
<img src="/assets/images/0905/4-4.png" alt="" /></p>
  </li>
</ol>

<p>这个算法的关键在于，<code class="highlighter-rouge">newHead</code> 和 <code class="highlighter-rouge">head</code> 所指向的节点是不变的，只是不断将 <code class="highlighter-rouge">head</code> 节点之后的节点移到 <code class="highlighter-rouge">newHead</code> 节点之后。实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Node</span> <span class="nf">reverseSinglyLinkedList4</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">newHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
	<span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

	<span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

		<span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="n">temp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
		<span class="n">newHead</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">newHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="递归实现">递归实现</h2>
<p>待续。</p>

<h2 id="leetcode-上的例子-25">leetcode 上的例子 （#25）</h2>
<p>待续。</p>

	
</div>

		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/none"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/none"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
