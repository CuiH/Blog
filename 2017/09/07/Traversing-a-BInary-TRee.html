<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Traversing a Binary Tree</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css">

	<!-- Font -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
</head>

<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">Traversing a Binary Tree</div>
	<span class="post-date">
		<time>07 Sep 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#algorithm">
					<span>algorithm</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="overview">Overview</h2>
<p>The <code class="highlighter-rouge">binary tree</code> is a very classical data structure, and we have various ways to perform preorder, inorder and postorder traversal on it. The class <code class="highlighter-rouge">TreeNode</code> used in this blog is defined as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="n">TreeNode</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">TreeNode</span> <span class="n">right</span><span class="o">;</span>

    <span class="n">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>If there’s no special statement, we use this tree in our examples:</p>

<p><img src="/assets/images/0907/0-0.png" alt="" /></p>

<h2 id="traversing-recursively">Traversing Recursively</h2>
<p>This may be the simplest algorithm of traversing, so I just post the code here:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">preorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

    <span class="n">preorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
    <span class="n">preorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">inorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

    <span class="n">inorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">postorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
    <span class="n">postorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="using-a-stack">Using a Stack</h2>
<p>The key point of traversing a binary tree is how to go back to the parent and traverse another child after we have traversed one child. Here we can use a <code class="highlighter-rouge">stack</code> to record visited nodes, and its <code class="highlighter-rouge">fitst-in-first-out</code> feature will perfectly help us go back to the parent after the traversal of a subtree.</p>

<h3 id="preorder-traversal">Preorder Traversal</h3>
<ol>
  <li>As for the current node, traverse along the <code class="highlighter-rouge">left child</code>, and keep outputing and pushing to the stack, until current node points to <code class="highlighter-rouge">null</code></li>
  <li>Pop the top node of the stack, whose <code class="highlighter-rouge">right child</code> will become the current node</li>
  <li>Repeat process #1 and #2, until current node points to <code class="highlighter-rouge">null</code> and the stack is empty</li>
</ol>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">preorderWithStack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span><span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="inorder-traversal">Inorder Traversal</h3>
<p>The thinking is similar to the preorder one, but this time we output at the time of popping (from stack). No need to describe the algorithm and here’s the code:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">inorderWithStack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span><span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="postorder-traversal">Postorder Traversal</h3>
<p>This could be a little more complicate. The point is, we should ensure that the parent node is not outputed until all of his children are traversed. A common method is to remember the last node we have outputed, which can act as a indicator for us to judge whether both the left child and the right child have been traversed at a given node. Here I provide three ideas.</p>

<p>a) just like the previous solution:</p>

<p>Similar to the preorder and inorder traversal code above. The difference is we record the last outputed node, and before popping the stack, we check whether both children of the top node in the stack have been traversed (or, is <code class="highlighter-rouge">null</code>), by comparing them with the recorded node:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithStack1</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">prev</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

            <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span>
            <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>b) another method:</p>

<ol>
  <li>The root is the current node, and push it to the stack</li>
  <li>Get the top node of the stack. If its children are all <code class="highlighter-rouge">null</code>, or have been traversed (that is, one of them is the last outputed node), pop it and outout it; otherwise push its <code class="highlighter-rouge">right</code> child into the stack (if is not <code class="highlighter-rouge">null</code>), and then its <code class="highlighter-rouge">left</code> node (if is not <code class="highlighter-rouge">null</code>)</li>
  <li>Repeat process #2, until the stack becomes empty</li>
</ol>

<p>The code is as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithStack2</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
 
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="n">prev</span> <span class="o">||</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">prev</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>c) using two stacks</p>

<p>This method is somewhat magical. We know that the sequence of postorder traversal is <code class="highlighter-rouge">left -&gt; right -&gt; mid</code>. What if we traverse with <code class="highlighter-rouge">mid -&gt; right -&gt; left</code> and then reverse the result? We can do this using two stacks, traversing with one stack, and outputing the result to another stack, and finally popping nodes from the second stack one by one to get the postorder traversal:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithTwoStacks</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">resStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">resStack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">resStack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">resStack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="level-traversal">Level Traversal</h2>
<p>In some cases, we may need to traverse a binary tree level by level. Obviously, using <code class="highlighter-rouge">queue</code> is a good choice. Since it’s simple, only the code:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">levelTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
        <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="morris-traversal">Morris Traversal</h2>
<p>The average space complexity of all of the algorithms above, except the recursive ones and the two-stack solution, is <code class="highlighter-rouge">O(logn)</code>. Is there any binary tree traversal algorithm with <code class="highlighter-rouge">O(1)</code> space complexity? The answer is “yes”.
Such method is called the <code class="highlighter-rouge">Morris Traversal</code>. Here is the description of the <code class="highlighter-rouge">inorder</code> one：</p>

<ol>
  <li>If the <code class="highlighter-rouge">left</code> child of current node is <code class="highlighter-rouge">null</code>, output it, and then traverse its <code class="highlighter-rouge">right</code> child</li>
  <li>If the <code class="highlighter-rouge">left</code> child is not <code class="highlighter-rouge">null</code>, find the inorder <code class="highlighter-rouge">predecessor</code> in its left subtree. If the <code class="highlighter-rouge">right</code> child of the predecessor is <code class="highlighter-rouge">null</code>, make it point to the current node, and then traverse the left child of the current node; if the right child of the predecessor is current node, revert it to <code class="highlighter-rouge">null</code>, and output current node, and then traverse the right node of the current node</li>
  <li>Repeat process #1 and #2, until the currrent node points to <code class="highlighter-rouge">null</code></li>
</ol>

<p>Here it involves a concept, the <code class="highlighter-rouge">inorder predecessor</code>:</p>

<blockquote>
  <p>Given a node, the node before it in the inorder traversal is its inorder predecessor.</p>
</blockquote>

<p>The common way to find it is to continuously traverse <code class="highlighter-rouge">right</code> in the <code class="highlighter-rouge">left</code> subtree of a node, until the right child is <code class="highlighter-rouge">null</code>.</p>

<p>The ingenuity of this algorithm is that, we utilize the empty space <code class="highlighter-rouge">inside</code> the tree to help us go back to the parent node, without any extra sapce. When we traverse the left subtree of a node, we first save current node to the right child of the predecessor of it. After we finish the traversal of the left subtree (and arrive at the predecessor), according to the algorithm we will go to the right child of the last node (because its left child is <code class="highlighter-rouge">null</code>) and thus successfully come back to the parent! Then, at the parent node, we find the right child of its predecessor is <code class="highlighter-rouge">itselt</code>, which means the left subtree has been traversed, so we move to the right subtree.</p>

<p>As for our example, a detailed description is:</p>

<ol>
  <li>
    <p>The original tree
<img src="/assets/images/0907/T-0.png" alt="" /></p>
  </li>
  <li>
    <p>Find the predecessor and change its right child, and then traverse the left subtree of current node
<img src="/assets/images/0907/T-1.png" alt="" /></p>
  </li>
  <li>
    <p>The same as above
<img src="/assets/images/0907/T-2.png" alt="" /></p>
  </li>
  <li>
    <p>The left child is <code class="highlighter-rouge">null</code>, so output current node
<img src="/assets/images/0907/T-3.png" alt="" /></p>
  </li>
  <li>
    <p>Traverse the right subtree, and come back to the parent
<img src="/assets/images/0907/T-4.png" alt="" /></p>
  </li>
  <li>
    <p>The right child of the predecessor is self, so revert it and output current node. Traverse the right subtree
<img src="/assets/images/0907/T-5.png" alt="" /></p>
  </li>
  <li>
    <p>Handle the predecessor, and traverse the left subtree
<img src="/assets/images/0907/T-6.png" alt="" /></p>
  </li>
  <li>
    <p>The left child is null, so output current node. Traverse the right subtree, and come back to the parent
<img src="/assets/images/0907/T-7.png" alt="" /></p>
  </li>
  <li>
    <p>The right child of the predecessor is self, so revert it and output current node. Traverse the right subtree and come back to the parent
<img src="/assets/images/0907/T-8.png" alt="" /></p>
  </li>
  <li>
    <p>The right child of the predecessor is self, so revert it and output current node. Traverse the right subtree
<img src="/assets/images/0907/T-9.png" alt="" /></p>
  </li>
  <li>
    <p>The left child is <code class="highlighter-rouge">null</code>, so output current node, and traverse the right subtree
<img src="/assets/images/0907/T-10.png" alt="" /></p>
  </li>
  <li>
    <p>The same as above. Finsh the traversal
<img src="/assets/images/0907/T-11.png" alt="" /></p>
  </li>
</ol>

<p>Here’s the code:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">morrisInorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">TreeNode</span> <span class="n">predecessor</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="n">root</span><span class="o">)</span>
                <span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<hr />

<h2 id="总览">总览</h2>
<p>二叉树是一个十分经典的数据结构，可以对其进行前序、中序，以及后续遍历（这里不再介绍这三者的定义）。本文关注遍历二叉树的多种算法，并结合 Leetcode 题目具体分析。其中，树节点的定义如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
	<span class="n">TreeNode</span> <span class="n">left</span><span class="o">;</span>
	<span class="n">TreeNode</span> <span class="n">right</span><span class="o">;</span>

	<span class="n">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>如无特殊声明，本文使用的例子为如下二叉树：</p>

<p><img src="/assets/images/0907/0-0.png" alt="" /></p>

<h2 id="递归遍历">递归遍历</h2>
<p>这是最简单、最容易写的遍历算法，因此直接给出代码：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">preorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

	<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

	<span class="n">preorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
	<span class="n">preorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

	<span class="n">inorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

	<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

	<span class="n">inorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postorderWithRecursion</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

	<span class="n">postorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
	<span class="n">postorderWithRecursion</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>

	<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="使用栈遍历">使用栈遍历</h2>
<p>遍历一棵二叉树，沿着一条路径遍历下去后，关键在于如何回到已遍历过的节点继续沿另一条路径遍历，我们可以使用 <code class="highlighter-rouge">栈</code> 这个数据结构来存储访问过的节点。栈的 <code class="highlighter-rouge">后入先出</code> 特性可以帮助我们在便利完一棵子树后回到其父节点。</p>

<h3 id="先序遍历">先序遍历</h3>
<ol>
  <li>对于当前节点，沿左子树遍历，并不断输出、入栈，直至当前节点为空</li>
  <li>弹出栈顶节点，将其右子树设为当前节点</li>
  <li>重复步骤1-2，直至当前节点为空且栈为空</li>
</ol>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">preorderWithStack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">root</span><span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
			<span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="中序遍历">中序遍历</h3>
<p>与前序遍历思路类似，只是输出时机改在出栈操作的时候进行，故不再进行算法描述，直接给出代码：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">inorderWithStack</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">root</span><span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
		<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

		<span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h3 id="后序遍历">后序遍历</h3>
<p>稍微复杂一些，算法的关键在于，要保证父节点在左右子树都被遍历后才输出。常规的做法是，记录下最后一次输出的节点，帮助判断当前节点的左右子树是否都已被遍历。下面提供三种思路。</p>

<p>a) 延续之前的思路：</p>

<p>与前面先序、中序的代码类似，只是需要记录上一次输出的节点，并在出栈操作之前判断栈顶节点是否满足输出要求，即左右子树为空，或已被遍历过，实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithStack1</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">prev</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

			<span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

			<span class="n">prev</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span>
			<span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>b) 另一种思路：</p>

<ol>
  <li>将根节点设为当前节点，并入栈</li>
  <li>获取栈顶节点，若果该节点的左右子树均为空，或都已遍历过（即左右子树之一为上一次输出的节点），则将该节点出栈并输出；否则先将其右子树入栈（如果非空），再将左子树入栈（如果非空）</li>
  <li>重复步骤2，直至栈为空</li>
</ol>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithStack2</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
 
	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
	<span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

	<span class="n">TreeNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

	<span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
		<span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
		<span class="k">if</span> <span class="o">((</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="n">prev</span> <span class="o">||</span> <span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">prev</span><span class="o">))</span> <span class="o">{</span>
			<span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>

			<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

			<span class="n">prev</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<p>c) 使用双栈</p>

<p>这个算法的思路有些神奇，我们知道后序遍历的顺序是 <code class="highlighter-rouge">左 -&gt; 右 -&gt; 中</code>，那么如果我们先按照 <code class="highlighter-rouge">中 -&gt; 右 -&gt; 左</code> 的顺序遍历，将结果输出到另外一个栈中，最后再按顺序弹出第二个栈的元素，就可以得到原始树的后序遍历结果了。实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderWithTwoStacks</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    
	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">resStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
	<span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

	<span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
		<span class="n">TreeNode</span> <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
		<span class="n">resStack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">stack</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">top</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
	<span class="k">while</span> <span class="o">(!</span><span class="n">resStack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
		<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">resStack</span><span class="o">.</span><span class="na">removeLast</span><span class="o">());</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="层次遍历">层次遍历</h2>
<p>即一层一层遍历树，在某些情况下适用。很显然，使用 <code class="highlighter-rouge">队列</code> 可以较为简单实现，不多介绍，直接给出代码：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">levelTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
	<span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

	<span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
		<span class="n">TreeNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
		<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="morris-遍历">Morris 遍历</h2>
<p>前面提到的各种算法，除了递归和双栈外，平均空间复杂度都为 <code class="highlighter-rouge">O(logn)</code>，那么有没有空间复杂度为 <code class="highlighter-rouge">O(1)</code> 的遍历算法呢？答案是有的，这个算法被称作 <code class="highlighter-rouge">Morris Traversal</code>， 下面先给出中序遍历的算法描述：</p>

<ol>
  <li>如果当前节点左子树为空，则输出当前节点，并继续遍历右子树</li>
  <li>如果左子树非空，则在左子树中找出中序遍历下的 <code class="highlighter-rouge">前驱结点</code>，如果该节点的右子树为空，则将当前节点设为其右子树，继续遍历当前节点的左子树；如果该节点的右子树为当前节点，则恢复其为空，输出当前节点，继续遍历当前节点的右子树</li>
  <li>重复步骤1-2，直至当前节点为空</li>
</ol>

<p>这里涉及到一个概念，即中序遍历的 <code class="highlighter-rouge">前驱结点</code>：</p>

<blockquote>
  <p>对于给定节点，其在中序遍历下的输出中的前一个节点被称作前驱结点。</p>
</blockquote>

<p>一般的寻找方法为，在左子树中一直向右前进，直至右子树为空。</p>

<p>这个算法的巧妙之处在于，利用树中节点的空余空间来帮助我们回到父节点，无需额外的存储空间。当遍历一个节点的左子树时，先将该节点链接到其前驱结点的右子树中，这样当遍历完左子树时（即到达前驱结点），根据算法会最后一个节点的右子树设为当前节点（成功回到父节点）。然后在处理父节点时，发现其前驱结点的右子树为自己，说明该左子树已完成遍历，应输出本身并继续遍历右子树。</p>

<p>对于我们的例子，分步描述如下：</p>

<ol>
  <li>
    <p>原始树
<img src="/assets/images/0907/T-0.png" alt="" /></p>
  </li>
  <li>
    <p>找到前驱结点设置其右子树，并遍历左子树
<img src="/assets/images/0907/T-1.png" alt="" /></p>
  </li>
  <li>
    <p>同上
<img src="/assets/images/0907/T-2.png" alt="" /></p>
  </li>
  <li>
    <p>左子树为空，输出
<img src="/assets/images/0907/T-3.png" alt="" /></p>
  </li>
  <li>
    <p>遍历右子树，回到父节点
<img src="/assets/images/0907/T-4.png" alt="" /></p>
  </li>
  <li>
    <p>发现前驱结点的右子树为自己，删除该右子树，输出当前节点，遍历右子树
<img src="/assets/images/0907/T-5.png" alt="" /></p>
  </li>
  <li>
    <p>处理前驱结点，遍历左子树
<img src="/assets/images/0907/T-6.png" alt="" /></p>
  </li>
  <li>
    <p>左子树为空，输出，遍历右子树，回到父节点
<img src="/assets/images/0907/T-7.png" alt="" /></p>
  </li>
  <li>
    <p>发现前驱结点的右子树为自己，删除该右子树，输出当前节点，遍历右子树，回到父节点
<img src="/assets/images/0907/T-8.png" alt="" /></p>
  </li>
  <li>
    <p>发现前驱结点的右子树为自己，删除该右子树，输出当前节点，遍历右子树
<img src="/assets/images/0907/T-9.png" alt="" /></p>
  </li>
  <li>
    <p>发现左子树为空，输出当前节点，遍历右节点
<img src="/assets/images/0907/T-10.png" alt="" /></p>
  </li>
  <li>
    <p>同上，完成遍历
<img src="/assets/images/0907/T-11.png" alt="" /></p>
  </li>
</ol>

<p>实现代码如下：</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">morrisInorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

	<span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">TreeNode</span> <span class="n">predecessor</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="n">root</span><span class="o">)</span>
				<span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
				<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="n">predecessor</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

				<span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>

				<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</code></pre>
</div>

	
</div>

		<div class="footer">
	<hr />
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/none"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/none"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2017 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
