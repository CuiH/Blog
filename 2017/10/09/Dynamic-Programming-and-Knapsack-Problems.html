<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<title>Dynamic Programming and Knapsack Problems</title>

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css" type="text/css" />

	<!-- Font -->
	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" />
	<link href="http://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css" rel="stylesheet" type="text/css" />
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet" type="text/css" />
</head>


<body>
	<div class="content-container">
		<header>
	<div class="header-small">
		<a href="http://cuih.xyz">Life is a Struggle</a>
	</div>
</header>

<div class="post">
	<div class="post-title">Dynamic Programming and Knapsack Problems</div>
	<span class="post-date">
		<time>09 Oct 2017</time>
	</span>
	<div class="post-tag">
		<ul>
			
			<li>
				<a href="http://cuih.xyz/tags#algorithm">
					<span>algorithm</span>
				</a>
			</li>
			
			
		</ul>
	</div>

	<h2 id="overview">Overview</h2>
<p><code class="highlighter-rouge">Dynamic Programming (DP)</code> is very common in sloving problems. Many people tend to think that it is difficult, but actually, if you understand the principles, it can be easy to use. In this blog, I will give a brief introduction to DP and analyze with maybe the most typical DP problem, the <code class="highlighter-rouge">knapsack problem (s)</code>.</p>

<h2 id="an-example">An example</h2>
<p>Let’s see a problem on Leetcode first, <code class="highlighter-rouge">#322 Coin Change</code>:</p>

<blockquote>
  <p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>

  <p>Example:</p>

  <p>coins = [1, 2, 5], amount = 11</p>

  <p>return 3 (11 = 5 + 5 + 1)</p>

  <p>Note:</p>

  <p>You may assume that you have an infinite number of each kind of coin.</p>
</blockquote>

<p>At the first sight, a brute-force solution is quite straight-forward, that is, try every possible combinations and find the optimal one. So why don’t we start with that?</p>

<h3 id="the-easiest-recursive-solution">The easiest recursive solution</h3>
<p>It sounds good to handle this problem with recursion, and the code is rather simple:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChangeWithRecursion</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">minCount</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">coin:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">coin</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">coinChangeWithRecursion</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rest</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">minCount</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minCount</span><span class="o">,</span> <span class="n">rest</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">minCount</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">minCount</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>However, obviously, this may cause a TLE, because the code does many duplicate works. For example, if we have coins <code class="highlighter-rouge">[1, 2, 3]</code>, and the target amount is <code class="highlighter-rouge">20</code>. When we reach amount <code class="highlighter-rouge">1 + 2 + 2 (= 5)</code> and <code class="highlighter-rouge">2 + 3 (= 5)</code>, the rest of the code will do the same job, that try to find the minimum coins to make up <code class="highlighter-rouge">(20 - 5 =) 15</code>. As the target amount becomes larger, there will be exponentially more duplicate calculations. So, how to improve?</p>

<h3 id="recursion-with-memorization">Recursion with memorization</h3>
<p>As we have analyzed the drawback of the recursive solution, an intuitive improvement is to memorize every minCount (amount) we have already calculated:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChangeWithRecursionAndMemorization</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">amount</span><span class="o">))</span> <span class="k">return</span> <span class="n">memo</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">amount</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">minCount</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">coin:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">coin</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">coinChangeWithRecursionAndMemorization</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coin</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rest</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">minCount</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minCount</span><span class="o">,</span> <span class="n">rest</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">minCount</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">amount</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">memo</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">amount</span><span class="o">,</span> <span class="n">minCount</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">minCount</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This solution can pass the online judge, but we still need to invoke this method many times. Can we get the result with only one invocation? Maybe we can use an array.</p>

<h3 id="a-better-solution--dp">A better solution – DP</h3>
<p>Since we’ll always calculate from big <code class="highlighter-rouge">amount</code> to small <code class="highlighter-rouge">amount</code>, why don’t we start from small <code class="highlighter-rouge">amount</code> and remember the results, so big <code class="highlighter-rouge">amount</code> can directly make use of them:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChangeWithDP</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">==</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is the so-called <code class="highlighter-rouge">DP</code>.</p>

<h2 id="the-simplest-knapsack-problem">The simplest knapsack problem</h2>
<p>Now that we have learnt what <code class="highlighter-rouge">DP</code> is, we can move to perhaps the most typical DP problem, the <code class="highlighter-rouge">knapsack problem</code>. Actually, there are many variations, so we will begin with the simplest one, the <code class="highlighter-rouge">0/1 knapsack problem</code>.</p>

<blockquote>
  <p>Suppose there are many objects with different weights and values, and you have a knapsack of limited capacity, how to fill in the knapsack to achieve the greatest total value?</p>
</blockquote>

<p>It is called the <code class="highlighter-rouge">0/1 knapsack</code> because for each item, you can either pick it up or not. You may realize that this problem is just like the previous <code class="highlighter-rouge">coin change</code> problem! The only difference is we want to find the maximum total value rather than the minimum coin count.</p>

<p>For a DP problem, the most important task is to find the <code class="highlighter-rouge">state transition equation</code>. Following the principle in the coin problem, we start from small problems, and use an array to remember the calculated results, i.e., <code class="highlighter-rouge">dp[n][c]</code>, where <code class="highlighter-rouge">n</code> is the number of items, and <code class="highlighter-rouge">c</code> is the capacity of the knapsack. For each state, we calculate the maximum value by trying all two possibilities – to <code class="highlighter-rouge">include</code> that item or <code class="highlighter-rouge">not</code>. The equation is:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dp[i][j] = max(dp[i - 1][j - weight[i]] + value[i], dp[i - 1][j])
</code></pre></div></div>

<p>The pseudocode is as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = [1 ... n]
    for j = [weight[i] ... capacity]
        dp[i][j] = max(dp[i - 1][j - weight[i]] + value[i], dp[i - 1][j])
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">j</code> starts from <code class="highlighter-rouge">weight[i]</code> since an item won’t be considered if its weight is greater than the capacity of the knapsack.</p>

<p>The final result is in <code class="highlighter-rouge">dp[n][c]</code>.</p>

<p>This code can still be optimized. You may find the first dimension of the array is somewhat redundant because we only use the previous <code class="highlighter-rouge">one</code> round results. Therefore, we can adopt a <code class="highlighter-rouge">rolling array</code> to save space.</p>

<p>In fact, the only reason why we use a two-dimension array is to avoid picking up the same item multiple times, but if we start from the <code class="highlighter-rouge">back</code>, one dimension is enougth, since we only use the results of smaller capacities (j - weight[i]):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = [0 ... n)
    for j = [capacity ... weight[i]]
        dp[j] = max(dp[j - weight[i]] + value[i], dp[j])
</code></pre></div></div>

<h2 id="the-complete-knapsack-problem">The complete knapsack problem</h2>
<p>It is similar to the 0/1 knapsack, but this time, we can use an item multiple times. It’s simple! As I mentioned above, we start from the back to avoid counting one item more than once, so for a <code class="highlighter-rouge">complete knapsack</code>, we just simply start from the beginning:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = [0 ... n)
    for j = [weight[i] ... capacity]
        dp[j] = max(dp[j - weight[i]] + value[i], dp[j])
</code></pre></div></div>

<h2 id="the-multidimensional-knapsack-problem">The multidimensional knapsack problem</h2>
<p>There is an example on LeetCode, <code class="highlighter-rouge">#474 Ones and Zeroes</code>:</p>

<blockquote>
  <p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>

  <p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>

  <p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>

  <p>Example:</p>

  <p>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3</p>

  <p>Output: 4</p>

  <p>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10”, “0001”, “1”, “0”.</p>
</blockquote>

<p>The main difference is that now the <code class="highlighter-rouge">knapsack</code> has two restrictions, i.e., <code class="highlighter-rouge">1</code>s and <code class="highlighter-rouge">0</code>s, but the principle never changes. Similar to the rolling array 0/1 knapsack solution, we use a two-dimension array to remember the states, and try to include every string, from the back to front (to avoid using one string more than once):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findMaxForm</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="nl">ch:</span> <span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">'0'</span><span class="o">)</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]++;</span>
            <span class="k">else</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">t</span><span class="o">++)</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">[</span><span class="n">t</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span> <span class="n">i</span><span class="o">--)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">[</span><span class="n">t</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span> <span class="n">j</span><span class="o">--)</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">c</span><span class="o">[</span><span class="n">t</span><span class="o">][</span><span class="mi">0</span><span class="o">]][</span><span class="n">j</span> <span class="o">-</span> <span class="n">c</span><span class="o">[</span><span class="n">t</span><span class="o">][</span><span class="mi">1</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>
<p>DP is a very powerful tool, but to know whether a problem can be solved with DP, and how to derive the state transition equation, you need to do many exercises.</p>

</div>

		
		<div class="footer">
	<hr/>
	<div class="footer-link">
		
		<a href="https://www.facebook.com/none"><i class="fa fa-facebook" aria-hidden="true"></i></a>
		

		
		<a href="https://twitter.com/dontsay_lazy"><i class="fa fa-twitter" aria-hidden="true"></i></a>
		

		
		<a href="https://github.com/CuiH"><i class="fa fa-github" aria-hidden="true"></i></a>
		

		
		<a href="https://www.linkedin.com/in/hao-cui-3ab90214b"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
		

		
		<a href="mailto:hcui1995@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
		
	</div>

	© 2018 CuiH. All rights reserved.
</div>

	</div>
</body>
</html>
