---
layout: post
title:  "对 java 内存模型的理解"
date:   2017-09-03 23:00:00 -0500
tags:   java
description: JVM 中的堆内存与栈内存
---

## 什么是JVM
Java 一个很重要的特性是与平台无关性，而这正是靠 JVM 来实现的。JVM 用有自己的指令集、寄存器等，屏蔽了底层操作系统的相关信息。Java 程序在编译时只需生成 JVM 能读懂的字节码，运行时 JVM 根据不同操作系统生成相应的机器指令执行。

## JVM的结构
JVM 在执行 Java 程序的时候，其内存主要分为如下几个区域：
* 方法区 Method Area：存储加载的类信息，以及类中 static 变量等，是 GC 中的持久代区，同时是 `线程共享` 的。
* 常量池 Constant Pool：存储类中的 final 常量，类名、方法名等，是编译期就已经确定的。
* 程序计数器 Program Counter Register：每个 `线程独立` 拥有，存储当前执行的指令的内存地址。
* 本地方法栈 Native Method Stack：为 native 方法服务。
* 栈 Stack：每个线程拥有自己的栈，每个方法拥有自己的栈帧，其中存储一些 `基本数据类型变量` （如int，boolean），`非基本类型变量在堆中的地址引用`，以及返回值信息等。栈顶指向当前活动的栈帧（即方法帧）。
* 堆 Heap：JVM 管理的内存中最大的一块区域，`线程共享`，所有由 `new` 操作创建的对象的内存在此分配（包括对象实例、数组等）。是 `GC` 的主要活动区域。

## Java 的内存分配
总的来说，Java 对于基本数据类型以及对象的内存分配的处理是不同的：
* 基本数据类型：包括 byte, short, int, long, float, double, boolean, char。当在方法中定义这些变量时，JVM 会在线程栈中为它们直接分配存储空间。当变量超过其作用域时，空间被释放。
* 由 `new` 创建的对象以及数组：在堆中分配存储空间，而在方法中产生的对这些 `对象的引用` 存储在栈中。如果一个对象没有任何引用指向它，它所占的空间不会立即被释放，而是等待某个特定的时间由 GC 进行释放。

## Java 的栈内存、堆内存与参数传递
不同于 C++，Java 中没有指针这一概念，对象在堆中创建，程序在栈中执行，因此操作的始终是 `对象的引用`，比如，下面这段程序：
``` java
class A {
	int value;
}

public class Test {

	public static void main(String[] args) {
		A a1 = new A();
		a1.value = 5;

		System.out.println(a1.value);  // 5

		update(a1);

		System.out.println(a1.value);  // 8
	}

	private static void update(A a2) {
		a2.value = 8;
	}

}
```
`update()` 函数的参数 `a2` 接收了对象的引用，运行时 JVM 根据引用的地址在堆中找到这个对象，并对其 `value` 成员变量进行修改。由于堆内存是全局共享的，这个修改对 `main()` 函数中对象的另一个引用 `a1` 立即可见，因此两次输出的结果不同。

对于上面的例子，如果我们将 A 换为一个基本数据类型，如 int，则结果完全不同。
``` java
public class Test {

	public static void main(String[] args) {
		int a1 = 5;

		System.out.println(a1);  // 5

		update(a1);

		System.out.println(a1);  // 5
	}

	private static void update(int a2) {
		a2 = 5;
	}

}
```
JVM 中的栈相对于堆存取速度更快，所以对于生存期已知、大小已知的基本数据类型，直接在栈中为其分配空间。

*注意： 如果使用了 java 的包装类 `Integer`，或者是基本类型的数组如 `int[]`，则结果与第一个例子相同，因此主要的区分方法是：是否使用 `new` 操作符进行创建。

## 特殊的数据类型：String
你应该注意到，前面提到的 Java 中八种基本数据类型没有包括 String，但是请看下面的例子：
``` java
String a = "test";
String b = "test";

System.out.println(a == b);   // true
```
似乎 Stirng 表现出与基本数据类型的一样的特性，这是因为 JVM 对 String 进行了特殊的处理。前面提到的 JVM 内存区域中的 `常量池` 中有一部分为 `字符串常量池` ，在创建字符串时，JVM 首先在这个池中寻找是否存在同字面的字符串，如果存在，返回这个对象的引用，若不存在，则创建新的字符串常量。

再来回答一个十分经典的问题：
``` java
String a = new String("test");
```
这行代码创建了几个对象？答案是两个，首先在字符创常量池中创建 `"test"`,由于使用了 `new` 操作符，再在堆中创建新的 `String` 对象。

如果你理解了前面的内容，下面语句的结果就显而易见了：
``` java
String a = new String("test");
String b = new String("test");

System.out.println(a == b);   // false
```

这里引申一句题外话，java 中的 `==` 操作符比较的是变量引用的地址，因此对于对象不能直接使用 `==` 进行比较。如果只是比较 String 的字面值，可以使用其自带的 `equals()` 函数：
``` java
String a = new String("test");
String b = new String("test");

System.out.println(a.equals(b));   // true
```

另外，java 更推荐直接使用字符串常量池创建字符串，而不是通过 `new` 操作符。

最后，我们来探讨一下编译器的有趣之处，看下面的例子：
``` java
String a = "aaabbb";
String b = "aaa" + "bbb";

System.out.println(a == b);   // true
```
编译器似乎十分“聪明”，在编译期对我们的语句进行了一些优化。不过，编译器也没有那么“聪明”：
``` java
String a = "aaa";
String b = "bbb";

String m = "aaabbb";
String n = a + b;

System.out.println(m == n);   // false
```
如果在 `+` 操作符的两边存在非常量，即使连接后的字符串存在于常量池中，依旧会创建新的对象。
