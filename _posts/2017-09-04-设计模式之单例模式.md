---
layout: post
title:  "设计模式之单例模式"
date:   2017-09-04 23:00:00 -0500
tags:   java design-pattern
description: 实现单例模式的多种方式以及对线程安全的考虑。
---

## 定义
在一些情况下，我们的程序需要保证某个类只有一个实例存在，比如 Java 中的 `打印机` 类，`线程池` 类。这种设计在设计模式中被称作单例模式，定义如下：

> 确保一个类只有一个实例，并提供一个全局访问点。

这听起来似乎很好实现，但在实际应用的时候，还有很多需要考虑的因素。

## 最简单的单例模式
先来回答一个有趣的问题，Java 的构造方法可以修饰为 `private` 吗？

``` java
public class Test {

	private Test() { }

}
```

事实上，这是可以编译通过的，那么这样做有什么意义呢？如何实例化这个类？我们知道，私有方法只能在类内调用，既然构造方法是私有的，在没有实例的情况下如何进入这个类的内部呢？

答案已经显而易见了，我们可以创建一个公有静态方法来调用：

``` java
public class Test {

	public static void create() {
		new Test();
	}

	private Test() {

	}

}
```

这为我们实现简单的单例模式提供了思路，可以通过全局的静态方法控制实例的数量。如果在 `Intellij` 中选择创建一个单例模式的类，会得到如下模板：

``` java
public class SimpleSingleton {
	
	private static SimpleSingleton ourInstance = new SimpleSingleton();

	public static SimpleSingleton getInstance() {
		return ourInstance;
	}

	private SimpleSingleton() { }
	
}
```

似乎已经完美解决了问题！但是，如果你对 `Java类加载机制` 有一定了解，就会知道 static 代码在类加载的时候就会被执行，如果不巧初始化过程十分耗费时间，而这个实例被创建后又始终未使用，将形成浪费。

## 懒汉模式与饿汉模式
前面提到的方法被称作 `饿汉模式`，即：

> 无论实例何时使用以及是否被使用，总是急切的在类加载时就创建实例。

与之相对，还有另外一种实现方法：

``` java
public class SimpleSingleton {

	private static SimpleSingleton ourInstance = null;

	public static SimpleSingleton getInstance() {
		if (ourInstance == null)                   // a
		    ourInstance = new SimpleSingleton();   // b

		return ourInstance;
	}

	private SimpleSingleton() { }

}
```

这被称作 `懒汉模式`：

> 只在第一次请求实例的时候进行创建，之后直接返回已创建的实例。

## 线程安全
懒汉模式虽然实现了延迟加载，但却有一个致命的问题：它是线程不安全的。对于上面的代码，如果有如下的调用顺序，将产生两个不同的实例：

1. 线程1进入 getInstance() 方法，通过 [a] 处的 if 判断，在执行 [b] 处之前，时间片结束。
2. 线程2进入 getInstance() 方法，此时 ourInstance 仍旧为 null，线程2通过 if 判断，执行 [b] 处代码，创建新的 SimpleSigleton 实例，并返回。
3. 线程1执行 [b] 处代码，创建新的 SimpleSingleton 实例，这将覆盖线程2创建的实例，并返回新的实例。

为了解决这个问题，可以使用 Java 的 `同步（加锁）` 机制：

``` java
public static synchronized  SimpleSingleton getInstance() {
	if (ourInstance == null) ourInstance = new SimpleSingleton();

	return ourInstance;
}
```

被 `synchronized` 修饰的方法可以保证在同一时间只有一个线程能访问这个方法，这实现了线程安全，但却带来了 `性能` 上的问题：Java 在处理同步方法时需要进行加锁、解锁操作，这将耗费一定资源以及时间。

事实上，分析这段代码可以发现，只有在第一次创建实例的时候需要同步，之后直接返回已经创建的实例就可以了。如果在实际应用时需要多次访问这个函数，除了第一次访问之外的同步操作都是无意义的。

## 双重检查锁定
为了实现线程安全，同时解决效率问题，有人提出了更复杂的解决方案，即使用双重检查锁定：

``` java
public static synchronized  SimpleSingleton getInstance() {
	if (ourInstance == null) {
		synchronized (SimpleSingleton.class) {
			if (ourInstance == null) {
				ourInstance = new SimpleSingleton();
			}
		}
	}

	return ourInstance;
}
```

因为只有创建实例这一条语句需要锁定，改为采用同步代码块而不是同步整个方法，这样只有未被实例化的情况下访问才进行同步操作，提高了性能。

同时为了避免懒汉模式中遇到的问题，在同步操作后再次检查 ourInstance 是否已被实例化。由于同一时间只有一个线程可以进入同步代码块，这保证了只有一个实例被创建。

*注意：由于是静态方法，同步块锁定的是整个类。

## JVM 带来的问题
双重检查锁定看似已经很完美了，但很遗憾，实际使用时依然会出现问题。这是因为 JVM 允许编译器对指令进行 `重排序`，将无法保证 `有序性`。这里涉及到更深入的分析，我不打算在这篇文章继续讨论，因此只给出一个结论：

> 在 `new` 操作完成之前，编译器可能提前将等号左端的引用变为 `非空`。在多线程环境下，这将返回一个 `未完全初始化` 的对象。

这看起来很荒唐，但却是真实存在的。幸运的是，Java 也提供了一种机制来解决这个问题：`volatile` 关键字。

``` java
public class SimpleSingleton {

	private static volatile SimpleSingleton ourInstance = null;  // a

	public static synchronized  SimpleSingleton getInstance() {
		if (ourInstance == null) {
			synchronized (SimpleSingleton.class) {
				if (ourInstance == null) {
					ourInstance = new SimpleSingleton();
				}
			}
		}

		return ourInstance;
	}

	private SimpleSingleton() { }

}
```

注意 [a] 处，我们为 ourInstance 加上了 `volatile` 关键字，关于它的具体作用，我（应该）会在另一篇文章讨论，这里只需要知道，volatile `禁止 Java 进行指令重排序`，这样，就可以实现一个线程安全的单例模式。
