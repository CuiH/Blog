---
layout: post
title:  "翻转单链表的5种方法"
date:   2017-09-05 23:30:00 -0500
tags:   algorithm
description: 分别介绍5种翻转单链表的算法并提供实例，最后结合 leetcode 题目具体分析。
---

## 总览
常见的对单链表进行翻转有5种方法，下面将分别介绍。其中，类 `Node` 的定义如下：

``` java
public class Node {

	int val;
	Node next;
	
	Node(int v) {
		val = v;
	}

}
```

## 使用数组存储
遍历单链表，并将其存储在可 `随机访问` 的数据结构（如数组）中，随后反向遍历该数据结构，构建新的链表。由于最简单，不多做介绍，直接给出代码：

``` java
public Node reverseSinglyLinkedList1(Node head) {
	if (head == null || head.next == null) return head;

	List<Node> arr = new ArrayList<>();
	while (head != null) {
		arr.add(head);
		head = head.next;
	}

	Node curr = null;
	for (int i = arr.size() - 1; i >= 0; i--) {
		if (curr == null) {
			curr = arr.get(i);
		} else {
			curr.next = arr.get(i);
			curr = curr.next;
		}
	}

	curr.next = null;

	return arr.get(arr.size() - 1);
}
```

很明显，这个代码最大的问题就是空间代价太大，需要建立一个与链表等长的数据结构。

## 不断翻转每两个节点之间的指向
如果把相邻两个节点的指向逐一翻转，最终将实现对整个链表的翻转，描述如下：

* 定义 `currHead`，`next` 两个变量，分别指向当前链表的头以及头的下一个节点；额外定义变量 `temp` 用于临时储存节点。
* 首先将 `currHead` （省略“指向的”，下同）节点的下一个节点指向 `null`。
* 进入循环。
* 将 `temp` 指向 `next` 节点的下一个节点。
* 将 `next` 节点的下一个节点指向 `currHead` 节点。
* 将 `currHead` 指向 `next` 节点；将 `next` 指向 `temp` 节点。
* 循环直至 `next` 节点 为 `null`。
* `currHead` 节点即为翻转后链表的头。

用具体的例子可能更方便理解。假设有链表 `1 -> 2-> 3 -> 4 -> 5 -> null`，翻转过程如下：

1. 初始链表
![](/assets/images/0905/2-0.png)

2. 初始化
![](/assets/images/0905/2-1.png)

3. 进入循环
![](/assets/images/0905/2-2.png)

4. 翻转前两个节点的指向
![](/assets/images/0905/2-3.png)

5. 向前移动
![](/assets/images/0905/2-4.png)

6. 开始第二次循环
![](/assets/images/0905/2-5.png)

7. 继续循环直至 `next` 指向 `null`，此时 `currHead` 指向翻转后的节点头
![](/assets/images/0905/2-6.png)

代码如下：

``` java
public Node reverseSinglyLinkedList2(Node head) {
	if (head == null || head.next == null) return head;

	Node temp = null;
	Node currHead = head;
	Node next = currHead.next;

	currHead.next = null;

	while (next != null) {
		temp = next.next;

		next.next = currHead;

		currHead = next;
		next = temp;
	}

	return currHead;
}
```

## 不断将原链表的节点放到新链表的头部
这种方法思路和实现都不难，只需将原链表的节点逐一添加到新链表的头部即可。还是 `1 -> 2 -> 3 -> 4 -> 5 -> null` 的例子，翻转过程的描述和示例一起展示如下：

1. 初始化：`newHead` 指向 `null`，`head` 指向原链表的头
![](/assets/images/0905/3-0.png)

2. 进入循环：将 `temp` 指向 `head` 节点的下一个节点；将 `head` 节点的下一个节点指向 `newHead` 节点
![](/assets/images/0905/3-1.png)

3. 向前移动：将 `newHead` 指向 `head` 节点；将 `head` 指向 `temp` 节点
![](/assets/images/0905/3-2.png)

4. 进入下一次循环
![](/assets/images/0905/3-3.png)

5. 循环直至 `head` 指向 `null`，此时 `newHead` 指向翻转后的链表头
![](/assets/images/0905/3-4.png)

实现代码如下：

``` java
public Node reverseSinglyLinkedList3(Node head) {
	if (head == null || head.next == null) return head;

	Node temp = null;
	Node newHead = null;

	while (head != null) {
		temp = head.next;

		head.next = newHead;

		newHead = head;
		head = temp;
	}

	return newHead;
}
```

## 不断将原链表头的下一个节点插入新链表头之后
使用这个方法需要构造一个辅助节点，链接到原链表头之前，随后不断将原链表头的 `下一个节点` 插入到辅助节点之后，直至原链表头的下一个节点为 `null`，此时辅助节点的下一个节点即为翻转后链表的头。算法描述及示例如下：

1. 初始化：构造辅助节点 `newHead`，链接到原链表头
![](/assets/images/0905/4-0.png)

2. 进入循环：将 `temp` 指向 `head` 节点的下一个节点
![](/assets/images/0905/4-1.png)

3. 插入：将 `head` 节点的下一个节点指向 `temp` 的下一个节点；将 `temp` 节点的下一个节点指向 `newHead` 节点的下一个节点；将 `newHead` 节点的下一个节点指向 `temp` 节点。这样就将 `head` 节点的下一个节点插入到新链表头之后
![](/assets/images/0905/4-2.png)

4. 进入下一轮循环，操作同步骤2、3
![](/assets/images/0905/4-3.png)

5. 循环直至 `head` 节点的下一个节点为 `null`，此时 `newHead` 节点的下一个节点为翻转后链表的头
![](/assets/images/0905/4-4.png)

这个算法的关键在于，`newHead` 和 `head` 所指向的节点是不变的，只是不断将 `head` 节点之后的节点移到 `newHead` 节点之后。实现代码如下：

``` java
public Node reverseSinglyLinkedList4(Node head) {
	if (head == null || head.next == null) return head;

	Node newHead = new Node(0);
	newHead.next = head;

	Node temp = null;

	while (head.next != null) {
		temp = head.next;

		head.next = temp.next;
		temp.next = newHead.next;
		newHead.next = temp;
	}

	return newHead.next;
}
```

## 递归实现
待续。

## leetcode 上的例子 （#25）
待续。
