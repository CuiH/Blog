---
layout: post
title:  "二叉树的遍历"
date:   2017-09-07 00:30:00 -0500
tags:   algorithm
description: 使用递归、循环遍历二叉树（前、中、后序），并介绍 Morris 遍历。
---

## 总览
二叉树是一个十分经典的数据结构，可以对其进行前序、中序，以及后续遍历（这里不再介绍这三者的定义）。本文关注遍历二叉树的多种算法，并结合 Leetcode 题目具体分析。其中，树节点的定义如下：

``` java
public class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode(int x) { val = x; }
}
```

如无特殊声明，本文使用的例子为如下二叉树：

![](/assets/images/0907/0-0.png)

## 递归遍历
这是最简单、最容易写的遍历算法，因此直接给出代码：

``` java
public void preorderWithRecursion(TreeNode root, List<Integer> res) {
	if (root == null) return;

	res.add(root.val);

	preorderWithRecursion(root.left, res);
	preorderWithRecursion(root.right, res);
}

public void inorderWithRecursion(TreeNode root, List<Integer> res) {
	if (root == null) return;

	inorderWithRecursion(root.left, res);

	res.add(root.val);

	inorderWithRecursion(root.right, res);
}

public void postorderWithRecursion(TreeNode root, List<Integer> res) {
	if (root == null) return;

	postorderWithRecursion(root.left, res);
	postorderWithRecursion(root.right, res);

	res.add(root.val);
}
```

## 使用栈遍历
遍历一棵二叉树，沿着一条路径遍历下去后，关键在于如何回到已遍历过的节点继续沿另一条路径遍历，我们可以使用 `栈` 这个数据结构来存储访问过的节点。栈的 `后入先出` 特性可以帮助我们在便利完一棵子树后回到其父节点。

### 先序遍历
1. 对于当前节点，沿左子树遍历，并不断输出、入栈，直至当前节点为空
2. 弹出栈顶节点，将其右子树设为当前节点
3. 重复步骤1-2，直至当前节点为空且栈为空

实现代码如下：

``` java
public List<Integer> preorderWithStack(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();

	while (root != null || !stack.isEmpty()) {
		while (root!= null) {
			res.add(root.val);
			stack.addLast(root);

			root = root.left;
		}

		TreeNode top = stack.removeLast();
		root = top.right;
	}

	return res;
}
```

### 中序遍历
与前序遍历思路类似，只是输出时机改在出栈操作的时候进行，故不再进行算法描述，直接给出代码：

``` java
public List<Integer> inorderWithStack(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();

	while (root != null || !stack.isEmpty()) {
		while (root!= null) {
			stack.addLast(root);

			root = root.left;
		}

		TreeNode top = stack.removeLast();
		res.add(top.val);

		root = top.right;
	}

	return res;
}
```

### 后序遍历
稍微复杂一些，算法的关键在于，要保证父节点在左右子树都被遍历后才输出。常规的做法是，记录下最后一次输出的节点，帮助判断当前节点的左右子树是否都已被遍历。下面提供三种思路。

a) 延续之前的思路：

与前面先序、中序的代码类似，只是需要记录上一次输出的节点，并在出栈操作之前判断栈顶节点是否满足输出要求，即左右子树为空，或已被遍历过，实现代码如下：

``` java
public List<Integer> postorderWithStack1(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();

	TreeNode prev = null;

	while (root != null || !stack.isEmpty()) {
		while (root != null) {
			stack.addLast(root);

			root = root.left;
		}

		TreeNode top = stack.getLast();
		if (top.right == null || top.right == prev) {
			res.add(top.val);

			stack.removeLast();

			prev = top;
			root = null;
		} else {
			root = top.right;
		}
	}

	return res;
}
```

b) 另一种思路：

1. 将根节点设为当前节点，并入栈
2. 获取栈顶节点，若果该节点的左右子树均为空，或都已遍历过（即左右子树之一为上一次输出的节点），则将该节点出栈并输出；否则先将其右子树入栈（如果非空），再将左子树入栈（如果非空）
3. 重复步骤2，直至栈为空

实现代码如下：

``` java
public List<Integer> postorderWithStack2(TreeNode root) {
    if (root == null) return new ArrayList<>();
 
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();
	stack.addLast(root);

	TreeNode prev = null;

	while (!stack.isEmpty()) {
		TreeNode top = stack.getLast();
		if ((top.left == null && top.right == null) || (top.left == prev || top.right == prev)) {
			stack.removeLast();

			res.add(top.val);

			prev = top;
		} else {
			if (top.right != null) stack.addLast(top.right);
			if (top.left != null) stack.addLast(top.left);
		}
	}

	return res;
}
```

c) 使用双栈

这个算法的思路有些神奇，我们知道后序遍历的顺序是 `左 -> 右 -> 中`，那么如果我们先按照 `中 -> 右 -> 左` 的顺序遍历，将结果输出到另外一个栈中，最后再按顺序弹出第二个栈的元素，就可以得到原始树的后序遍历结果了。实现代码如下：

``` java
public List<Integer> postorderWithTwoStacks(TreeNode root) {
    if (root == null) return new ArrayList<>();
    
	LinkedList<Integer> resStack = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();
	stack.addLast(root);

	while (!stack.isEmpty()) {
		TreeNode top = stack.removeLast();
		resStack.addLast(top.val);

		if (top.left != null) stack.addLast(top.left);
		if (top.right != null) stack.addLast(top.right);
	}

	List<Integer> res = new LinkedList<>();
	while (!resStack.isEmpty())
		res.add(resStack.removeLast());

	return res;
}
```

## 层次遍历
即一层一层遍历树，在某些情况下适用。很显然，使用 `队列` 可以较为简单实现，不多介绍，直接给出代码：

``` java
public List<Integer> levelTraversal(TreeNode root) {
	if (root == null) return new ArrayList<>();

	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> queue = new LinkedList<>();
	queue.addLast(root);

	while (!queue.isEmpty()) {
		TreeNode first = queue.removeFirst();
		res.add(first.val);

		if (first.left != null) queue.addLast(first.left);
		if (first.right != null) queue.addLast(first.right);
	}

	return res;
}
```

## Morris 遍历
前面提到的各种算法，除了递归和双栈外，平均空间复杂度都为 `O(logn)`，那么有没有空间复杂度为 `O(1)` 的遍历算法呢？答案是有的，这个算法被称作 `Morris Traversal`， 下面先给出中序遍历的算法描述：

1. 如果当前节点左子树为空，则输出当前节点，并继续遍历右子树
2. 如果左子树非空，则在左子树中找出中序遍历下的 `前驱结点`，如果该节点的右子树为空，则将当前节点设为其右子树，继续遍历当前节点的左子树；如果该节点的右子树为当前节点，则恢复其为空，输出当前节点，继续遍历当前节点的右子树
3. 重复步骤1-2，直至当前节点为空

这里涉及到一个概念，即中序遍历的 `前驱结点`：

> 对于给定节点，其在中序遍历下的输出中的前一个节点被称作前驱结点。

一般的寻找方法为，在左子树中一直向右前进，直至右子树为空。

这个算法的巧妙之处在于，利用树中节点的空余空间来帮助我们回到父节点，无需额外的存储空间。当遍历一个节点的左子树时，先将该节点链接到其前驱结点的右子树中，这样当遍历完左子树时（即到达前驱结点），根据算法会最后一个节点的右子树设为当前节点（成功回到父节点）。然后在处理父节点时，发现其前驱结点的右子树为自己，说明该左子树已完成遍历，应输出本身并继续遍历右子树。

对于我们的例子，分步描述如下：

1. 原始树
![](/assets/images/0907/T-0.png)

2. 找到前驱结点设置其右子树，并遍历左子树
![](/assets/images/0907/T-1.png)

3. 同上
![](/assets/images/0907/T-2.png)

4. 左子树为空，输出
![](/assets/images/0907/T-3.png)

5. 遍历右子树，回到父节点
![](/assets/images/0907/T-4.png)

6. 发现前驱结点的右子树为自己，删除该右子树，输出当前节点，遍历右子树
![](/assets/images/0907/T-5.png)

7. 处理前驱结点，遍历左子树
![](/assets/images/0907/T-6.png)

8. 左子树为空，输出，遍历右子树，回到父节点
![](/assets/images/0907/T-7.png)

9. 发现前驱结点的右子树为自己，删除该右子树，输出当前节点，遍历右子树，回到父节点
![](/assets/images/0907/T-8.png)

10. 发现左子树前驱结点的右子树为自己，删除该右子树，输出当前节点，遍历右子树
![](/assets/images/0907/T-9.png)

11. 发现左子树为空，输出当前节点，遍历右节点
![](/assets/images/0907/T-10.png)

12. 同上，完成遍历
![](/assets/images/0907/T-11.png)

实现代码如下：

``` java
public List<Integer> morrisInorderTraversal(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	while (root != null) {
		if (root.left == null) {
			res.add(root.val);
			root = root.right;
		} else {
			TreeNode predecessor = root.left;
			while (predecessor.right != null && predecessor.right != root)
				predecessor = predecessor.right;

			if (predecessor.right == null) {
				predecessor.right = root;
				root = root.left;
			} else {
				predecessor.right = null;

				res.add(root.val);

				root = root.right;
			}
		}
	}

	return res;
}
```
