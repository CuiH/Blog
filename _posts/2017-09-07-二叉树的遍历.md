---
layout: post
title:  "二叉树的遍历"
date:   2017-09-07 00:30:00 -0500
tags:   algorithm
description: 使用递归、循环遍历二叉树（前、中、后序），并介绍 Morris 遍历。
---

## 总览
二叉树是一个十分经典的数据结构，可以对其进行前序、中序，以及后续遍历（这里不再介绍这三者的定义）。本文关注遍历二叉树的多种算法，并结合 Leetcode 题目具体分析。其中，树节点的定义如下：

``` java
public class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode(int x) { val = x; }
}
```

如无特殊声明，本文使用的例子为如下二叉树：

![](/assets/images/0907/0-0.png)

## 递归遍历
这是最简单、最容易写的遍历算法，因此直接给出代码：

``` java
public void preorderWithRecursion(TreeNode root, List<Integer> res) {
	if (root == null) return;

	res.add(root.val);

	preorderWithRecursion(root.left, res);
	preorderWithRecursion(root.right, res);
}

public void inorderWithRecursion(TreeNode root, List<Integer> res) {
	if (root == null) return;

	inorderWithRecursion(root.left, res);

	res.add(root.val);

	inorderWithRecursion(root.right, res);
}

public void postorderWithRecursion(TreeNode root, List<Integer> res) {
	if (root == null) return;

	postorderWithRecursion(root.left, res);
	postorderWithRecursion(root.right, res);

	res.add(root.val);
}
```

## 使用栈遍历
遍历一棵二叉树，沿着一条路径遍历下去后，关键在于如何回到已遍历过的节点继续沿另一条路径遍历，我们可以使用 `栈` 这个数据结构来存储访问过的节点。栈的 `后入先出 `特性可以帮助我们在便利完一棵子树后回到其父节点。

### 先序遍历
1. 对于当前节点，沿左子树遍历，并不断输出、入栈，直至当前节点为空
2. 弹出栈顶节点，将其右子树设为当前节点
3. 重复步骤1-2，直至当前节点为空且栈为空

实现代码如下：

``` java
public List<Integer> preorderWithStack(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();

	while (root != null || !stack.isEmpty()) {
		while (root!= null) {
			res.add(root.val);
			stack.addLast(root);

			root = root.left;
		}

		TreeNode top = stack.removeLast();
		root = top.right;
	}

	return res;
}
```

### 中序遍历
与前序遍历思路类似，只是输出时机改在出栈操作的时候进行，故不再进行算法描述，直接给出代码：

``` java
public List<Integer> inorderWithStack(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();

	while (root != null || !stack.isEmpty()) {
		while (root!= null) {
			stack.addLast(root);

			root = root.left;
		}

		TreeNode top = stack.removeLast();
		res.add(top.val);

		root = top.right;
	}

	return res;
}
```

### 后序遍历
稍微复杂一些，算法的关键在于，要保证父节点在左右子树都被遍历后才输出。常规的做法是，记录下最后一次输出的节点，帮助判断当前节点的左右子树是否都已被遍历。

a) 延续之前的思路：

与前面先序、中序的代码类似，只是需要记录上一次输出的节点，并在出栈操作之前判断栈顶节点是否满足输出要求，即左右子树为空，或已被便利过，实现代码如下：

``` java
public List<Integer> postorderWithStack2(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();

	TreeNode prev = null;

	while (root != null || !stack.isEmpty()) {
		while (root != null) {
			stack.addLast(root);

			root = root.left;
		}

		TreeNode top = stack.getLast();
		if (top.right == null || top.right == prev) {
			res.add(top.val);

			stack.removeLast();

			prev = top;
			root = null;
		} else {
			root = top.right;
		}
	}

	return res;
}
```

b) 另一种思路：

1. 将根节点设为当前节点，并入栈
2. 获取栈顶节点，若果该节点的左右子树均为空，或都已遍历过（即左右子树之一为上一次输出的节点），则将该节点出栈并输出；否则先将其右子树入栈（如果非空），再将左子树入栈（如果非空）
3. 重复步骤2，直至栈为空

实现代码如下：

``` java
public List<Integer> postorderWithStack1(TreeNode root) {
	List<Integer> res = new LinkedList<>();

	LinkedList<TreeNode> stack = new LinkedList<>();
	stack.addLast(root);

	TreeNode prev = null;

	while (!stack.isEmpty()) {
		TreeNode top = stack.getLast();
		if ((top.left == null && top.right == null) || (top.left == prev || top.right == prev)) {
			stack.removeLast();

			res.add(top.val);

			prev = top;
		} else {
			if (top.right != null) stack.addLast(top.right);
			if (top.left != null) stack.addLast(top.left);
		}
	}

	return res;
}
```

c) 使用双栈
待续。

##层次遍历
待续。

## Morris 遍历
待续。

## Leetcode 实例
